<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fragment Similarity Analysis</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
      color: #1f2933;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #1976d2;
      margin-bottom: 1rem;
    }
    .controls {
      background: #ffffff;
      border: 1px solid #e6eef7;
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 4px 12px rgba(25, 118, 210, 0.08);
    }
    .section-label {
      font-size: 12px;
      font-weight: 600;
      color: #546e7a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .compare-row {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items: end;
      margin-bottom: 16px;
    }
    .compare-row .vs {
      color: #90a4ae;
      font-weight: 600;
      font-size: 14px;
      padding-bottom: 10px;
    }
    .site-box {
      background: #f8fafc;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px;
    }
    .site-box.active {
      border-color: #1976d2;
      background: #e3f2fd;
    }
    .site-box label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      color: #546e7a;
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .site-box input {
      width: 100%;
      margin-bottom: 8px;
    }
    .site-box .filter-info {
      font-size: 11px;
      color: #1976d2;
      margin-top: 4px;
    }
    input, select {
      padding: 10px 12px;
      background: #ffffff;
      color: #1f2933;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #1976d2;
      box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
    }
    .search-input {
      padding-left: 40px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23546e7a' viewBox='0 0 24 24'%3E%3Cpath d='M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: 12px center;
      background-size: 20px;
    }
    button {
      padding: 10px 20px;
      background: #1976d2;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    button:hover { background: #1565c0; }
    button:disabled { background: #90caf9; cursor: not-allowed; }
    .btn-secondary {
      background: #ffffff;
      color: #1976d2;
      border: 1px solid #1976d2;
    }
    .btn-secondary:hover { background: #e3f2fd; }
    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }
    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .options-row {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .options-row label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: #546e7a;
    }
    #status {
      padding: 12px 16px;
      background: #e3f2fd;
      border-radius: 8px;
      margin-bottom: 1rem;
      color: #1565c0;
      font-size: 14px;
    }
    #status:empty { display: none; }
    #results { margin-top: 12px; }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(25, 118, 210, 0.08);
    }
    th, td {
      border-bottom: 1px solid #e6eef7;
      padding: 12px;
      font-size: 13px;
      text-align: left;
    }
    th {
      background: #f8fafc;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      color: #546e7a;
    }
    th:hover { background: #e3f2fd; }
    th .sort-icon { margin-left: 4px; opacity: 0.5; }
    th.sorted .sort-icon { opacity: 1; }
    tbody tr:hover { background: #f8fafc; }
    a { color: #1976d2; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .fragment-title {
      max-width: 280px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .fragment-host {
      font-size: 11px;
      color: #90a4ae;
    }
    .view-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: #e3f2fd;
      border-radius: 4px;
      font-size: 12px;
      color: #1976d2;
      border: none;
      cursor: pointer;
    }
    .view-btn:hover { background: #bbdefb; text-decoration: none; }
    .view-btn .material-icons { font-size: 14px; }
    .score-cell {
      font-family: monospace;
      font-weight: 500;
    }
    .score-high { color: #d32f2f; }
    .score-med { color: #f57c00; }
    .score-low { color: #388e3c; }

    /* Fragment preview modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: white;
      border-radius: 1rem;
      max-width: 800px;
      max-height: 80vh;
      width: 90%;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e6eef7;
      background: #f8fafc;
    }
    .modal-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: #1f2933;
    }
    .modal-close {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #546e7a;
    }
    .modal-close:hover { color: #1976d2; }
    .modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      max-height: 60vh;
    }
    .modal-body .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 1rem;
    }
    .modal-body .meta-tag {
      background: #e3f2fd;
      padding: 4px 10px;
      border-radius: 1rem;
      font-size: 12px;
      color: #1565c0;
    }
    .modal-body .content-preview {
      background: #f8fafc;
      padding: 1rem;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid #e6eef7;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    .filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
    }
    .filter-tag {
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      padding: 4px 10px;
      border-radius: 1rem;
      font-size: 12px;
      color: #546e7a;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filter-tag:hover { background: #e3f2fd; border-color: #90caf9; }
    .filter-tag.active-a {
      background: #e8f5e9;
      color: #2e7d32;
      border-color: #81c784;
    }
    .filter-tag.active-b {
      background: #fff3e0;
      color: #e65100;
      border-color: #ffb74d;
    }
    .filter-tag.active-both {
      background: #e3f2fd;
      color: #1565c0;
      border-color: #64b5f6;
    }
    .filter-tag .count {
      background: rgba(0,0,0,0.1);
      padding: 1px 5px;
      border-radius: 8px;
      margin-left: 4px;
      font-size: 10px;
    }
    .filter-legend {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: #90a4ae;
      margin-bottom: 8px;
    }
    .filter-legend span {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .filter-legend .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .filter-legend .dot-a { background: #81c784; }
    .filter-legend .dot-b { background: #ffb74d; }
    .filter-legend .dot-both { background: #64b5f6; }
  </style>
</head>
<body>
  <h2>Fragment Similarity Analysis</h2>

  <div class="controls">
    <div class="section-label">Filter by Category (click to apply to Site A, again for B, again to clear)</div>
    <div class="filter-legend">
      <span><span class="dot dot-a"></span> Site A only</span>
      <span><span class="dot dot-b"></span> Site B only</span>
      <span><span class="dot dot-both"></span> Both sites</span>
    </div>
    <div id="category-filters" class="filter-tags">
      <span style="color: #90a4ae; font-size: 13px;">Loading categories...</span>
    </div>

    <div class="section-label">Text Search (optional - filters fragments by content match)</div>
    <div class="row" style="margin-bottom: 16px;">
      <input id="search_query" type="text" class="search-input" placeholder="Search text to filter fragments..." style="max-width: 400px;" />
      <select id="search_apply">
        <option value="both">Apply to both sites</option>
        <option value="a">Apply to Site A only</option>
        <option value="b">Apply to Site B only</option>
      </select>
    </div>

    <div class="section-label">Compare Sites</div>
    <div class="compare-row">
      <div class="site-box" id="site-a-box">
        <label>Site A</label>
        <input id="site_a" placeholder="e.g., servicesaustralia.gov.au" value="servicesaustralia.gov.au" />
        <div class="filter-info" id="site-a-filters"></div>
      </div>
      <div class="vs">vs</div>
      <div class="site-box" id="site-b-box">
        <label>Site B</label>
        <input id="site_b" placeholder="e.g., my.gov.au" value="my.gov.au" />
        <div class="filter-info" id="site-b-filters"></div>
      </div>
    </div>

    <div class="options-row" style="margin-bottom: 12px;">
      <label>
        Metric:
        <select id="metric">
          <option value="combined">Combined</option>
          <option value="tags">Tags only</option>
          <option value="embedding">Embedding only</option>
        </select>
      </label>
      <label>
        Threshold:
        <input id="threshold" type="number" step="0.01" min="0" max="1" value="0.5" style="width: 70px;" />
      </label>
    </div>

    <div class="button-row">
      <button id="run">
        <span class="material-icons" style="font-size:18px">compare_arrows</span>
        Run Comparison
      </button>
      <button id="export_csv" class="btn-secondary">
        <span class="material-icons" style="font-size:18px">download</span>
        Download CSV
      </button>
      <button id="clear_filters" class="btn-secondary btn-small">
        <span class="material-icons" style="font-size:16px">clear_all</span>
        Clear Filters
      </button>
    </div>
  </div>

  <div id="status"></div>
  <div id="results"></div>

  <!-- Fragment Preview Modal -->
  <div id="modal-overlay" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modal-title">Fragment Preview</h3>
        <button class="modal-close" onclick="closeModal()">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div class="meta" id="modal-meta"></div>
        <div class="content-preview" id="modal-content"></div>
      </div>
      <div class="modal-footer">
        <a id="modal-link" href="#" target="_blank" class="view-btn">
          <span class="material-icons">open_in_new</span>
          Open Source Page
        </a>
      </div>
    </div>
  </div>

  <script>
    const TS_BASE = '/typesense';
    const TS_KEY = 'your-secure-api-key-here';

    // State
    const fragmentCache = new Map();
    let lastPairs = [];
    let currentPairs = [];
    let sortColumn = 'score';
    let sortAsc = false;
    let categoryFacets = [];

    // Filter state: 'none', 'a', 'b', 'both'
    const categoryFilters = new Map(); // category -> 'a' | 'b' | 'both'

    // Typesense helpers
    async function tsSearch(collection, params) {
      const query = new URLSearchParams(params).toString();
      const res = await fetch(`${TS_BASE}/collections/${encodeURIComponent(collection)}/documents/search?${query}`, {
        method: 'GET', headers: { 'X-TYPESENSE-API-KEY': TS_KEY }
      });
      if (!res.ok) throw new Error(`${collection} HTTP ${res.status}`);
      return await res.json();
    }

    async function tsFetchFiltered(collection, fields, hostFilter, categories, searchText, limit = 50000, statusFn = null) {
      const per_page = 250;
      let page = 1;
      const out = [];
      // Host filtering done client-side since Typesense doesn't support URL wildcards
      const hostMatch = hostFilter ? hostFilter.toLowerCase() : null;

      while (out.length < limit) {
        if (statusFn) statusFn(`Loading: ${out.length} fragments...`);

        const filters = [];
        // Category filter works in Typesense
        if (categories.length > 0) {
          const cats = categories.map(c => `"${c.replace(/"/g, '\\"')}"`);
          filters.push(`categories:=[${cats.join(',')}]`);
        }

        const params = {
          q: searchText || '*',
          query_by: searchText ? 'title,content_text' : 'title',
          include_fields: fields.join(','),
          per_page,
          page
        };
        if (filters.length) params.filter_by = filters.join(' && ');

        const data = await tsSearch(collection, params);
        const hits = data.hits || [];
        if (!hits.length) break;

        // Filter by host client-side
        for (const h of hits) {
          const doc = h.document;
          if (hostMatch) {
            const docHost = hostOf(doc.url || '').toLowerCase();
            if (!docHost.includes(hostMatch)) continue;
          }
          out.push(doc);
        }

        if (data.found <= page * per_page) break;
        page++;

        // Early exit if we have enough matching fragments
        if (out.length >= limit) break;
      }
      return out.slice(0, limit);
    }

    async function tsFacets(collection, facetField, maxFacets = 100) {
      const params = {
        q: '*',
        query_by: 'title',
        facet_by: facetField,
        max_facet_values: maxFacets,
        per_page: 0
      };
      return await tsSearch(collection, params);
    }

    // Utility functions
    function hostOf(u) {
      try { return new URL(u).hostname; }
      catch { return ''; }
    }

    function tokens(s) {
      return (s || '').toLowerCase().replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(Boolean);
    }

    function buildHashedEmbedding(text, dim = 256) {
      const v = new Array(dim).fill(0);
      for (const t of tokens(text)) {
        let h = 2166136261;
        for (let i = 0; i < t.length; i++) {
          h ^= t.charCodeAt(i);
          h = (h * 16777619) >>> 0;
        }
        v[h % dim]++;
      }
      const n = Math.sqrt(v.reduce((s, x) => s + x * x, 0)) || 1;
      return v.map(x => x / n);
    }

    function jaccard(a, b) {
      if (!a.size && !b.size) return 1;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const u = a.size + b.size - inter;
      return u ? inter / u : 0;
    }

    function cosine(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length || !a.length) return 0;
      let dot = 0, na = 0, nb = 0;
      for (let i = 0; i < a.length; i++) {
        const x = a[i] || 0, y = b[i] || 0;
        dot += x * y;
        na += x * x;
        nb += y * y;
      }
      return (!na || !nb) ? 0 : dot / Math.sqrt(na * nb);
    }

    function escHtml(s) {
      return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function prepareFragment(f) {
      return {
        id: f.id,
        url: f.url || '',
        title: f.title || f.hierarchy_lvl0 || 'Untitled',
        host: hostOf(f.url || ''),
        categories: new Set(f.categories || []),
        content_text: f.content_text || '',
        embedding: buildHashedEmbedding(f.content_text || '', 256),
        hierarchy_lvl0: f.hierarchy_lvl0,
        hierarchy_lvl1: f.hierarchy_lvl1,
        provider: f.provider
      };
    }

    function buildIndex(fragments) {
      const idxCat = new Map();
      const nrm = s => String(s || '').toLowerCase();
      for (let i = 0; i < fragments.length; i++) {
        const f = fragments[i];
        for (const cat of f.categories) {
          const k = nrm(cat);
          if (!idxCat.has(k)) idxCat.set(k, new Set());
          idxCat.get(k).add(i);
        }
      }
      return { idxCat };
    }

    function computePairs(A, B, metric, threshold, maxPairs, statusFn) {
      const { idxCat } = buildIndex(B);
      const nrm = s => String(s || '').toLowerCase();
      const pairs = [];
      const seen = new Set();
      let processed = 0;

      for (const a of A) {
        processed++;
        if (processed % 200 === 0 && statusFn) {
          statusFn(`Comparing: ${processed}/${A.length} fragments, ${pairs.length} pairs found...`);
        }

        const cand = new Set();
        for (const cat of a.categories) {
          const s = idxCat.get(nrm(cat));
          if (s) s.forEach(i => cand.add(i));
        }

        if (cand.size === 0 && metric !== 'tags') {
          for (let i = 0; i < Math.min(30, B.length); i++) {
            cand.add(Math.floor(Math.random() * B.length));
          }
        }

        for (const i of cand) {
          const b = B[i];
          if (!b || a.id === b.id || a.url === b.url) continue;

          const key = a.id < b.id ? a.id + '|' + b.id : b.id + '|' + a.id;
          if (seen.has(key)) continue;
          seen.add(key);

          const tagSim = jaccard(a.categories, b.categories);
          const embSim = cosine(a.embedding, b.embedding);

          let score;
          if (metric === 'tags') score = tagSim;
          else if (metric === 'embedding') score = embSim;
          else score = 0.4 * tagSim + 0.6 * embSim;

          if (score >= threshold) {
            pairs.push({ a, b, score, tagSim, embSim });
          }
        }

        if (pairs.length >= maxPairs) break;
      }

      pairs.sort((x, y) => y.score - x.score);
      return pairs.slice(0, maxPairs);
    }

    // Category filter UI
    async function loadCategories() {
      try {
        const data = await tsFacets('content_fragments', 'categories', 50);
        const facets = data.facet_counts?.find(f => f.field_name === 'categories')?.counts || [];
        categoryFacets = facets.sort((a, b) => b.count - a.count);
        renderCategoryFilters();
      } catch (e) {
        console.error('Failed to load categories:', e);
        document.getElementById('category-filters').innerHTML = '<span style="color:#d32f2f;font-size:13px;">Failed to load categories</span>';
      }
    }

    function renderCategoryFilters() {
      const container = document.getElementById('category-filters');
      if (!categoryFacets.length) {
        container.innerHTML = '<span style="color:#90a4ae;font-size:13px;">No categories found</span>';
        return;
      }

      container.innerHTML = categoryFacets.slice(0, 25).map(f => {
        const state = categoryFilters.get(f.value) || 'none';
        const cls = state === 'a' ? 'active-a' : state === 'b' ? 'active-b' : state === 'both' ? 'active-both' : '';
        return `<span class="filter-tag ${cls}" data-category="${escHtml(f.value)}">${escHtml(f.value)}<span class="count">${f.count}</span></span>`;
      }).join('');

      container.querySelectorAll('.filter-tag').forEach(tag => {
        tag.onclick = () => {
          const cat = tag.dataset.category;
          const current = categoryFilters.get(cat) || 'none';
          // Cycle: none -> a -> b -> both -> none
          const next = current === 'none' ? 'a' : current === 'a' ? 'b' : current === 'b' ? 'both' : 'none';
          if (next === 'none') {
            categoryFilters.delete(cat);
          } else {
            categoryFilters.set(cat, next);
          }
          renderCategoryFilters();
          updateFilterInfo();
        };
      });
    }

    function updateFilterInfo() {
      const catsA = [], catsB = [];
      for (const [cat, state] of categoryFilters) {
        if (state === 'a' || state === 'both') catsA.push(cat);
        if (state === 'b' || state === 'both') catsB.push(cat);
      }

      document.getElementById('site-a-filters').textContent = catsA.length ? `Filtered: ${catsA.join(', ')}` : '';
      document.getElementById('site-b-filters').textContent = catsB.length ? `Filtered: ${catsB.join(', ')}` : '';
    }

    function clearFilters() {
      categoryFilters.clear();
      document.getElementById('search_query').value = '';
      renderCategoryFilters();
      updateFilterInfo();
    }

    // Run comparison
    async function runComparison() {
      const siteA = document.getElementById('site_a').value.trim();
      const siteB = document.getElementById('site_b').value.trim();
      const metric = document.getElementById('metric').value;
      const threshold = parseFloat(document.getElementById('threshold').value || '0.5');
      const searchText = document.getElementById('search_query').value.trim();
      const searchApply = document.getElementById('search_apply').value;
      const status = document.getElementById('status');
      const runBtn = document.getElementById('run');

      if (!siteA || !siteB) {
        status.textContent = 'Please enter both Site A and Site B';
        return;
      }

      runBtn.disabled = true;
      status.textContent = 'Loading fragments...';

      try {
        // Build category filters for each side
        const catsA = [], catsB = [];
        for (const [cat, state] of categoryFilters) {
          if (state === 'a' || state === 'both') catsA.push(cat);
          if (state === 'b' || state === 'both') catsB.push(cat);
        }

        const searchA = (searchApply === 'a' || searchApply === 'both') ? searchText : '';
        const searchB = (searchApply === 'b' || searchApply === 'both') ? searchText : '';

        const fields = ['id', 'url', 'title', 'content_text', 'categories', 'hierarchy_lvl0', 'hierarchy_lvl1', 'provider'];

        // Fetch fragments for each side
        status.textContent = `Loading Site A (${siteA})...`;
        const fragsA = await tsFetchFiltered('content_fragments', fields, siteA, catsA, searchA, 25000, msg => status.textContent = `Site A: ${msg}`);

        status.textContent = `Loading Site B (${siteB})...`;
        const fragsB = await tsFetchFiltered('content_fragments', fields, siteB, catsB, searchB, 25000, msg => status.textContent = `Site B: ${msg}`);

        if (!fragsA.length) throw new Error(`No fragments found for ${siteA}`);
        if (!fragsB.length) throw new Error(`No fragments found for ${siteB}`);

        // Cache and prepare
        status.textContent = `Preparing ${fragsA.length + fragsB.length} fragments...`;
        fragsA.forEach(f => fragmentCache.set(f.id, f));
        fragsB.forEach(f => fragmentCache.set(f.id, f));

        const preparedA = fragsA.map(prepareFragment);
        const preparedB = fragsB.map(prepareFragment);

        status.textContent = `Comparing ${preparedA.length} vs ${preparedB.length} fragments...`;

        lastPairs = computePairs(preparedA, preparedB, metric, threshold, 10000, msg => status.textContent = msg);

        renderTable(lastPairs.slice(0, 200));

        const filterInfo = [];
        if (catsA.length) filterInfo.push(`A filtered by ${catsA.length} categories`);
        if (catsB.length) filterInfo.push(`B filtered by ${catsB.length} categories`);
        if (searchA) filterInfo.push(`A searched "${searchA}"`);
        if (searchB) filterInfo.push(`B searched "${searchB}"`);

        status.textContent = `Found ${lastPairs.length} similar pairs (showing top 200). ${filterInfo.join(', ')}`;
      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        console.error(e);
      } finally {
        runBtn.disabled = false;
      }
    }

    const columns = [
      { key: 'fragA', label: 'Site A Fragment', getValue: p => (p.a.title || '').toLowerCase() },
      { key: 'fragB', label: 'Site B Fragment', getValue: p => (p.b.title || '').toLowerCase() },
      { key: 'score', label: 'Score', getValue: p => p.score },
      { key: 'tagSim', label: 'Tags', getValue: p => p.tagSim },
      { key: 'embSim', label: 'Embed', getValue: p => p.embSim },
    ];

    function sortPairs(pairs, colKey, asc) {
      const col = columns.find(c => c.key === colKey);
      if (!col) return pairs;
      return [...pairs].sort((a, b) => {
        const va = col.getValue(a), vb = col.getValue(b);
        if (va < vb) return asc ? -1 : 1;
        if (va > vb) return asc ? 1 : -1;
        return 0;
      });
    }

    function scoreClass(score) {
      if (score >= 0.8) return 'score-high';
      if (score >= 0.6) return 'score-med';
      return 'score-low';
    }

    function renderTable(pairs, preserveSort = false) {
      const el = document.getElementById('results');
      if (!pairs.length) {
        el.innerHTML = '<p style="padding: 2rem; text-align: center; color: #607d8b;">No similar fragments found. Try lowering the threshold or adjusting filters.</p>';
        return;
      }
      currentPairs = pairs;
      if (!preserveSort) { sortColumn = 'score'; sortAsc = false; }
      const sorted = sortPairs(pairs, sortColumn, sortAsc);

      const rows = sorted.map(p => `
        <tr>
          <td>
            <div class="fragment-title">${escHtml(p.a.title)}</div>
            <div class="fragment-host">${escHtml(p.a.host)}</div>
            <button class="view-btn" onclick="showFragment('${p.a.id}')">
              <span class="material-icons">visibility</span> View
            </button>
          </td>
          <td>
            <div class="fragment-title">${escHtml(p.b.title)}</div>
            <div class="fragment-host">${escHtml(p.b.host)}</div>
            <button class="view-btn" onclick="showFragment('${p.b.id}')">
              <span class="material-icons">visibility</span> View
            </button>
          </td>
          <td class="score-cell ${scoreClass(p.score)}">${p.score.toFixed(3)}</td>
          <td class="score-cell">${p.tagSim.toFixed(3)}</td>
          <td class="score-cell">${p.embSim.toFixed(3)}</td>
        </tr>`).join('');

      const headers = columns.map(c => {
        const isSorted = sortColumn === c.key;
        const icon = isSorted ? (sortAsc ? '▲' : '▼') : '⇅';
        return `<th data-col="${c.key}" class="${isSorted ? 'sorted' : ''}">${c.label}<span class="sort-icon">${icon}</span></th>`;
      }).join('');

      el.innerHTML = `
        <table>
          <thead><tr>${headers}</tr></thead>
          <tbody>${rows}</tbody>
        </table>`;

      el.querySelectorAll('th').forEach(th => {
        th.onclick = () => {
          const col = th.dataset.col;
          if (sortColumn === col) { sortAsc = !sortAsc; }
          else { sortColumn = col; sortAsc = col === 'fragA' || col === 'fragB'; }
          renderTable(currentPairs, true);
        };
      });
    }

    // Modal
    function showFragment(id) {
      const f = fragmentCache.get(id);
      if (!f) { alert('Fragment not found'); return; }

      document.getElementById('modal-title').textContent = f.title || f.hierarchy_lvl0 || 'Fragment Preview';

      const meta = [];
      if (f.provider) meta.push(`Provider: ${f.provider}`);
      if (f.hierarchy_lvl0) meta.push(f.hierarchy_lvl0);
      if (f.hierarchy_lvl1) meta.push(f.hierarchy_lvl1);
      (f.categories || []).forEach(c => meta.push(c));

      document.getElementById('modal-meta').innerHTML = meta.map(m => `<span class="meta-tag">${escHtml(m)}</span>`).join('');
      document.getElementById('modal-content').textContent = f.content_text || '(No content)';
      document.getElementById('modal-link').href = f.url || '#';
      document.getElementById('modal-overlay').classList.add('active');
    }

    function closeModal() {
      document.getElementById('modal-overlay').classList.remove('active');
    }

    // CSV export
    function toCSV(rows) {
      if (!rows.length) return '';
      const headers = Object.keys(rows[0]);
      const esc = v => '"' + String(v == null ? '' : v).replace(/"/g, '""') + '"';
      return [headers.join(','), ...rows.map(r => headers.map(h => esc(r[h])).join(','))].join('\n');
    }

    function download(name, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/plain' }));
      a.download = name;
      a.click();
    }

    function exportCSV() {
      if (!lastPairs.length) return alert('Run comparison first');
      const rows = lastPairs.map(p => ({
        a_id: p.a.id, a_url: p.a.url, a_title: p.a.title || '',
        b_id: p.b.id, b_url: p.b.url, b_title: p.b.title || '',
        score: p.score.toFixed(3), tag_sim: p.tagSim.toFixed(3), emb_sim: p.embSim.toFixed(3)
      }));
      download('fragment_similarity.csv', toCSV(rows));
    }

    // Event listeners
    document.getElementById('modal-overlay').addEventListener('click', e => { if (e.target.id === 'modal-overlay') closeModal(); });
    document.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });
    document.getElementById('run').addEventListener('click', runComparison);
    document.getElementById('export_csv').addEventListener('click', exportCSV);
    document.getElementById('clear_filters').addEventListener('click', clearFilters);
    document.getElementById('search_query').addEventListener('keydown', e => { if (e.key === 'Enter') runComparison(); });

    // Initialize
    loadCategories();
  </script>
</body>
</html>
