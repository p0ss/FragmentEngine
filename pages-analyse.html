<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fragment Similarity Analysis</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
      color: #1f2933;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #1976d2;
      margin-bottom: 1rem;
    }
    .controls {
      background: #ffffff;
      border: 1px solid #e6eef7;
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 4px 12px rgba(25, 118, 210, 0.08);
    }
    .section-label {
      font-size: 12px;
      font-weight: 600;
      color: #546e7a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .row.search-row {
      grid-template-columns: 1fr auto;
    }
    input, select {
      padding: 10px 12px;
      background: #f8fafc;
      color: #1f2933;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #1976d2;
      box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
    }
    .search-input {
      padding-left: 40px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23546e7a' viewBox='0 0 24 24'%3E%3Cpath d='M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: 12px center;
      background-size: 20px;
    }
    button {
      padding: 10px 20px;
      background: #1976d2;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    button:hover { background: #1565c0; }
    button:disabled { background: #90caf9; cursor: not-allowed; }
    .btn-secondary {
      background: #ffffff;
      color: #1976d2;
      border: 1px solid #1976d2;
    }
    .btn-secondary:hover { background: #e3f2fd; }
    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    #status {
      padding: 12px 16px;
      background: #e3f2fd;
      border-radius: 8px;
      margin-bottom: 1rem;
      color: #1565c0;
      font-size: 14px;
    }
    #status:empty { display: none; }
    #results { margin-top: 12px; }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(25, 118, 210, 0.08);
    }
    th, td {
      border-bottom: 1px solid #e6eef7;
      padding: 12px;
      font-size: 13px;
      text-align: left;
    }
    th {
      background: #f8fafc;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      color: #546e7a;
    }
    th:hover { background: #e3f2fd; }
    th .sort-icon { margin-left: 4px; opacity: 0.5; }
    th.sorted .sort-icon { opacity: 1; }
    tbody tr:hover { background: #f8fafc; }
    a { color: #1976d2; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .fragment-title {
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .view-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: #e3f2fd;
      border-radius: 4px;
      font-size: 12px;
      color: #1976d2;
      border: none;
      cursor: pointer;
    }
    .view-btn:hover { background: #bbdefb; text-decoration: none; }
    .view-btn .material-icons { font-size: 14px; }
    .score-cell {
      font-family: monospace;
      font-weight: 500;
    }
    .score-high { color: #d32f2f; }
    .score-med { color: #f57c00; }
    .score-low { color: #388e3c; }
    .tag-highlight {
      background: #fff3e0;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      color: #e65100;
      margin-left: 6px;
    }

    /* Fragment preview modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: white;
      border-radius: 1rem;
      max-width: 800px;
      max-height: 80vh;
      width: 90%;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e6eef7;
      background: #f8fafc;
    }
    .modal-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: #1f2933;
    }
    .modal-close {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #546e7a;
    }
    .modal-close:hover { color: #1976d2; }
    .modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      max-height: 60vh;
    }
    .modal-body .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 1rem;
    }
    .modal-body .meta-tag {
      background: #e3f2fd;
      padding: 4px 10px;
      border-radius: 1rem;
      font-size: 12px;
      color: #1565c0;
    }
    .modal-body .content-preview {
      background: #f8fafc;
      padding: 1rem;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid #e6eef7;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    .filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .filter-tag {
      background: #e3f2fd;
      border: 1px solid #90caf9;
      padding: 4px 10px;
      border-radius: 1rem;
      font-size: 12px;
      color: #1565c0;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filter-tag:hover { background: #bbdefb; }
    .filter-tag.active {
      background: #1976d2;
      color: white;
      border-color: #1976d2;
    }
    .filter-tag .count {
      background: rgba(255,255,255,0.3);
      padding: 1px 5px;
      border-radius: 8px;
      margin-left: 4px;
      font-size: 10px;
    }
    .filter-tag.active .count { background: rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <h2>Fragment Similarity Analysis</h2>

  <div class="controls">
    <div class="section-label">Search & Filter</div>
    <div class="row search-row">
      <input id="search_query" type="text" class="search-input" placeholder="Search fragments by text..." />
      <button id="search_btn" type="button">
        <span class="material-icons" style="font-size:18px">search</span>
        Search
      </button>
    </div>

    <div class="section-label">Category Filter</div>
    <div id="category-filters" class="filter-tags">
      <span style="color: #90a4ae; font-size: 13px;">Loading categories...</span>
    </div>

    <div class="section-label" style="margin-top: 16px;">Similarity Comparison</div>
    <div class="row">
      <input id="site_a" placeholder="Site A (e.g., servicesaustralia.gov.au)" value="servicesaustralia.gov.au" />
      <input id="site_b" placeholder="Site B (e.g., my.gov.au)" value="my.gov.au" />
      <select id="metric">
        <option value="combined">Metric: Combined</option>
        <option value="tags">Metric: Tags only</option>
        <option value="embedding">Metric: Embedding only</option>
      </select>
      <input id="threshold" type="number" step="0.01" min="0" max="1" value="0.5" placeholder="Threshold" />
    </div>
    <div class="button-row">
      <button id="run">
        <span class="material-icons" style="font-size:18px">compare_arrows</span>
        Run Similarity Analysis
      </button>
      <button id="export_csv" class="btn-secondary">
        <span class="material-icons" style="font-size:18px">download</span>
        Download CSV
      </button>
    </div>
  </div>

  <div id="status"></div>
  <div id="results"></div>

  <!-- Fragment Preview Modal -->
  <div id="modal-overlay" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modal-title">Fragment Preview</h3>
        <button class="modal-close" onclick="closeModal()">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div class="meta" id="modal-meta"></div>
        <div class="content-preview" id="modal-content"></div>
      </div>
      <div class="modal-footer">
        <a id="modal-link" href="#" target="_blank" class="view-btn">
          <span class="material-icons">open_in_new</span>
          Open Source Page
        </a>
      </div>
    </div>
  </div>

  <script>
    // Configuration - hardcoded since this is an internal tool
    const TS_BASE = '/typesense';
    const TS_KEY = 'your-secure-api-key-here';

    // State
    const fragmentCache = new Map();
    let allFragments = [];
    let preparedFragments = [];
    let lastPairs = [];
    let currentPairs = [];
    let sortColumn = 'score';
    let sortAsc = false;
    let selectedCategories = new Set();
    let categoryFacets = [];

    // Typesense helpers
    async function tsSearch(collection, params) {
      const query = new URLSearchParams(params).toString();
      const res = await fetch(`${TS_BASE}/collections/${encodeURIComponent(collection)}/documents/search?${query}`, {
        method: 'GET', headers: { 'X-TYPESENSE-API-KEY': TS_KEY }
      });
      if (!res.ok) {
        const err = new Error(`${collection} HTTP ${res.status}`);
        err.status = res.status;
        throw err;
      }
      return await res.json();
    }

    async function tsFetchAll(collection, fields, filter = '', limit = 50000, statusFn = null) {
      const per_page = 250;
      let page = 1;
      const out = [];
      while (out.length < limit) {
        if (statusFn) statusFn(`Loading ${collection}: ${out.length} documents...`);
        let data;
        try {
          const params = {
            q: '*',
            query_by: 'title',
            include_fields: fields.join(','),
            per_page,
            page
          };
          if (filter) params.filter_by = filter;
          data = await tsSearch(collection, params);
        } catch (e) {
          if (e && (e.status === 404 || String(e.message || '').includes('HTTP 404'))) {
            return out;
          }
          throw e;
        }
        const hits = data.hits || [];
        if (!hits.length) break;
        hits.forEach(h => out.push(h.document));
        if (data.found <= page * per_page) break;
        page++;
      }
      return out.slice(0, limit);
    }

    async function tsFacets(collection, facetField, filter = '', maxFacets = 100) {
      const params = {
        q: '*',
        query_by: 'title',
        facet_by: facetField,
        max_facet_values: maxFacets,
        per_page: 0
      };
      if (filter) params.filter_by = filter;
      return await tsSearch(collection, params);
    }

    // Utility functions
    function hostOf(u) {
      try { return new URL(u).hostname; }
      catch { return ''; }
    }

    function tokens(s) {
      return (s || '').toLowerCase().replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(Boolean);
    }

    function buildHashedEmbedding(text, dim = 256) {
      const v = new Array(dim).fill(0);
      for (const t of tokens(text)) {
        let h = 2166136261;
        for (let i = 0; i < t.length; i++) {
          h ^= t.charCodeAt(i);
          h = (h * 16777619) >>> 0;
        }
        v[h % dim]++;
      }
      const n = Math.sqrt(v.reduce((s, x) => s + x * x, 0)) || 1;
      return v.map(x => x / n);
    }

    function jaccard(a, b) {
      if (!a.size && !b.size) return 1;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const u = a.size + b.size - inter;
      return u ? inter / u : 0;
    }

    function cosine(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length || !a.length) return 0;
      let dot = 0, na = 0, nb = 0;
      for (let i = 0; i < a.length; i++) {
        const x = a[i] || 0, y = b[i] || 0;
        dot += x * y;
        na += x * x;
        nb += y * y;
      }
      return (!na || !nb) ? 0 : dot / Math.sqrt(na * nb);
    }

    function escHtml(s) {
      return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // Fragment preparation
    function prepareFragments(frags) {
      return frags.map(f => ({
        id: f.id,
        url: f.url || '',
        title: f.title || f.hierarchy_lvl0 || 'Untitled',
        host: hostOf(f.url || ''),
        categories: new Set(f.categories || []),
        content_text: f.content_text || '',
        embedding: buildHashedEmbedding(f.content_text || '', 256),
        hierarchy_lvl0: f.hierarchy_lvl0,
        hierarchy_lvl1: f.hierarchy_lvl1,
        provider: f.provider
      }));
    }

    function buildIndex(fragments) {
      const idxCat = new Map();
      const nrm = s => String(s || '').toLowerCase();
      for (let i = 0; i < fragments.length; i++) {
        const f = fragments[i];
        for (const cat of f.categories) {
          const k = nrm(cat);
          if (!idxCat.has(k)) idxCat.set(k, new Set());
          idxCat.get(k).add(i);
        }
      }
      return { idxCat };
    }

    function computePairs(A, B, metric, threshold, maxPairs, statusFn) {
      const { idxCat } = buildIndex(B);
      const nrm = s => String(s || '').toLowerCase();
      const pairs = [];
      const seen = new Set();
      let processed = 0;

      for (const a of A) {
        processed++;
        if (processed % 500 === 0 && statusFn) {
          statusFn(`Computing pairs: ${processed}/${A.length} fragments, ${pairs.length} pairs found...`);
        }

        const cand = new Set();
        for (const cat of a.categories) {
          const s = idxCat.get(nrm(cat));
          if (s) s.forEach(i => cand.add(i));
        }

        if (cand.size === 0 && metric !== 'tags') {
          for (let i = 0; i < Math.min(50, B.length); i++) {
            cand.add(Math.floor(Math.random() * B.length));
          }
        }

        for (const i of cand) {
          const b = B[i];
          if (!b) continue;
          if (a.id === b.id || a.url === b.url) continue;

          const key = a.id + '|' + b.id;
          const keyRev = b.id + '|' + a.id;
          if (seen.has(key) || seen.has(keyRev)) continue;
          seen.add(key);

          const tagSim = jaccard(a.categories, b.categories);
          const embSim = cosine(a.embedding, b.embedding);

          let score;
          if (metric === 'tags') score = tagSim;
          else if (metric === 'embedding') score = embSim;
          else score = 0.4 * tagSim + 0.6 * embSim;

          if (score >= threshold) {
            pairs.push({ a, b, score, tagSim, embSim });
          }
        }

        if (pairs.length >= maxPairs) break;
      }

      pairs.sort((x, y) => y.score - x.score);
      return pairs.slice(0, maxPairs);
    }

    // Category filter UI
    async function loadCategories() {
      try {
        const data = await tsFacets('content_fragments', 'categories', '', 50);
        const facets = data.facet_counts?.find(f => f.field_name === 'categories')?.counts || [];
        categoryFacets = facets.sort((a, b) => b.count - a.count);
        renderCategoryFilters();
      } catch (e) {
        console.error('Failed to load categories:', e);
        document.getElementById('category-filters').innerHTML = '<span style="color:#d32f2f;font-size:13px;">Failed to load categories</span>';
      }
    }

    function renderCategoryFilters() {
      const container = document.getElementById('category-filters');
      if (!categoryFacets.length) {
        container.innerHTML = '<span style="color:#90a4ae;font-size:13px;">No categories found</span>';
        return;
      }

      container.innerHTML = categoryFacets.slice(0, 20).map(f => `
        <span class="filter-tag ${selectedCategories.has(f.value) ? 'active' : ''}" data-category="${escHtml(f.value)}">
          ${escHtml(f.value)}<span class="count">${f.count}</span>
        </span>
      `).join('');

      container.querySelectorAll('.filter-tag').forEach(tag => {
        tag.onclick = () => {
          const cat = tag.dataset.category;
          if (selectedCategories.has(cat)) {
            selectedCategories.delete(cat);
            tag.classList.remove('active');
          } else {
            selectedCategories.add(cat);
            tag.classList.add('active');
          }
        };
      });
    }

    // Search functionality
    async function runSearch() {
      const query = document.getElementById('search_query').value.trim();
      const status = document.getElementById('status');
      const searchBtn = document.getElementById('search_btn');

      searchBtn.disabled = true;
      status.textContent = 'Searching...';

      try {
        // Build filter from selected categories
        let filter = '';
        if (selectedCategories.size > 0) {
          const cats = Array.from(selectedCategories).map(c => `"${c.replace(/"/g, '\\"')}"`);
          filter = `categories:=[${cats.join(',')}]`;
        }

        const params = {
          q: query || '*',
          query_by: 'title,content_text',
          include_fields: 'id,url,title,content_text,categories,hierarchy_lvl0,hierarchy_lvl1,provider',
          per_page: 100,
          page: 1
        };
        if (filter) params.filter_by = filter;

        const data = await tsSearch('content_fragments', params);
        const frags = (data.hits || []).map(h => h.document);

        // Cache fragments
        frags.forEach(f => fragmentCache.set(f.id, f));

        // Render search results
        renderSearchResults(frags, data.found, query);
        status.textContent = `Found ${data.found} fragments${query ? ` matching "${query}"` : ''}${selectedCategories.size ? ` in ${selectedCategories.size} categories` : ''} (showing ${frags.length})`;
      } catch (e) {
        status.textContent = 'Search error: ' + e.message;
        console.error(e);
      } finally {
        searchBtn.disabled = false;
      }
    }

    function renderSearchResults(frags, total, query) {
      const el = document.getElementById('results');
      if (!frags.length) {
        el.innerHTML = '<p style="padding: 2rem; text-align: center; color: #607d8b;">No fragments found. Try different search terms or filters.</p>';
        return;
      }

      const rows = frags.map(f => {
        const cats = (f.categories || []).slice(0, 3).map(c => `<span class="tag-highlight">${escHtml(c)}</span>`).join('');
        return `
          <tr>
            <td>
              <div class="fragment-title">${escHtml(f.title || f.hierarchy_lvl0 || 'Untitled')}</div>
              <button class="view-btn" onclick="showFragment('${f.id}')">
                <span class="material-icons">visibility</span> View
              </button>
            </td>
            <td style="max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escHtml((f.content_text || '').slice(0, 150))}...</td>
            <td>${cats}</td>
            <td><a href="${escHtml(f.url)}" target="_blank" style="font-size:12px;">${escHtml(hostOf(f.url))}</a></td>
          </tr>`;
      }).join('');

      el.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Fragment</th>
              <th>Content Preview</th>
              <th>Categories</th>
              <th>Source</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>`;
    }

    // Similarity analysis
    async function runSimilarity() {
      const siteA = document.getElementById('site_a').value.trim();
      const siteB = document.getElementById('site_b').value.trim();
      const metric = document.getElementById('metric').value;
      const threshold = parseFloat(document.getElementById('threshold').value || '0.5');
      const status = document.getElementById('status');
      const runBtn = document.getElementById('run');

      runBtn.disabled = true;
      status.textContent = 'Loading fragments...';

      try {
        // Build filter from selected categories
        let filter = '';
        if (selectedCategories.size > 0) {
          const cats = Array.from(selectedCategories).map(c => `"${c.replace(/"/g, '\\"')}"`);
          filter = `categories:=[${cats.join(',')}]`;
        }

        const fields = ['id', 'url', 'title', 'content_text', 'categories', 'hierarchy_lvl0', 'hierarchy_lvl1', 'provider'];
        const frags = await tsFetchAll('content_fragments', fields, filter, 50000, msg => status.textContent = msg);

        if (!frags || frags.length === 0) {
          throw new Error('No content_fragments found');
        }

        status.textContent = `Preparing ${frags.length} fragments...`;
        frags.forEach(f => fragmentCache.set(f.id, f));

        const prepared = prepareFragments(frags);
        const A = prepared.filter(f => f.host.endsWith(siteA));
        const B = prepared.filter(f => f.host.endsWith(siteB));

        status.textContent = `Comparing ${A.length} fragments from ${siteA} with ${B.length} from ${siteB}...`;

        lastPairs = computePairs(A, B, metric, threshold, 10000, msg => status.textContent = msg);

        renderSimilarityTable(lastPairs.slice(0, 200));
        const catInfo = selectedCategories.size ? ` (filtered by ${selectedCategories.size} categories)` : '';
        status.textContent = `Found ${lastPairs.length} similar fragment pairs${catInfo}. Showing top 200. Threshold: ${threshold}, Metric: ${metric}`;
      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        console.error(e);
      } finally {
        runBtn.disabled = false;
      }
    }

    const columns = [
      { key: 'fragA', label: 'Fragment A', getValue: p => (p.a.title || '').toLowerCase() },
      { key: 'fragB', label: 'Fragment B', getValue: p => (p.b.title || '').toLowerCase() },
      { key: 'score', label: 'Score', getValue: p => p.score },
      { key: 'tagSim', label: 'Tags', getValue: p => p.tagSim },
      { key: 'embSim', label: 'Embed', getValue: p => p.embSim },
    ];

    function sortPairs(pairs, colKey, asc) {
      const col = columns.find(c => c.key === colKey);
      if (!col) return pairs;
      return [...pairs].sort((a, b) => {
        const va = col.getValue(a), vb = col.getValue(b);
        if (va < vb) return asc ? -1 : 1;
        if (va > vb) return asc ? 1 : -1;
        return 0;
      });
    }

    function scoreClass(score) {
      if (score >= 0.8) return 'score-high';
      if (score >= 0.6) return 'score-med';
      return 'score-low';
    }

    function renderSimilarityTable(pairs, preserveSort = false) {
      const el = document.getElementById('results');
      if (!pairs.length) {
        el.innerHTML = '<p style="padding: 2rem; text-align: center; color: #607d8b;">No similar fragments found. Try lowering the threshold.</p>';
        return;
      }
      currentPairs = pairs;
      if (!preserveSort) { sortColumn = 'score'; sortAsc = false; }
      const sorted = sortPairs(pairs, sortColumn, sortAsc);

      const rows = sorted.map(p => `
        <tr>
          <td>
            <div class="fragment-title">${escHtml(p.a.title || p.a.url)}</div>
            <button class="view-btn" onclick="showFragment('${p.a.id}')">
              <span class="material-icons">visibility</span> View
            </button>
          </td>
          <td>
            <div class="fragment-title">${escHtml(p.b.title || p.b.url)}</div>
            <button class="view-btn" onclick="showFragment('${p.b.id}')">
              <span class="material-icons">visibility</span> View
            </button>
          </td>
          <td class="score-cell ${scoreClass(p.score)}">${p.score.toFixed(3)}</td>
          <td class="score-cell">${p.tagSim.toFixed(3)}</td>
          <td class="score-cell">${p.embSim.toFixed(3)}</td>
        </tr>`).join('');

      const headers = columns.map(c => {
        const isSorted = sortColumn === c.key;
        const icon = isSorted ? (sortAsc ? '▲' : '▼') : '⇅';
        return `<th data-col="${c.key}" class="${isSorted ? 'sorted' : ''}">${c.label}<span class="sort-icon">${icon}</span></th>`;
      }).join('');

      el.innerHTML = `
        <table>
          <thead><tr>${headers}</tr></thead>
          <tbody>${rows}</tbody>
        </table>`;

      el.querySelectorAll('th').forEach(th => {
        th.onclick = () => {
          const col = th.dataset.col;
          if (sortColumn === col) { sortAsc = !sortAsc; }
          else { sortColumn = col; sortAsc = col === 'fragA' || col === 'fragB'; }
          renderSimilarityTable(currentPairs, true);
        };
      });
    }

    // Modal
    function showFragment(id) {
      const f = fragmentCache.get(id);
      if (!f) {
        alert('Fragment not found in cache');
        return;
      }

      document.getElementById('modal-title').textContent = f.title || f.hierarchy_lvl0 || 'Fragment Preview';

      const meta = [];
      if (f.provider) meta.push(`Provider: ${f.provider}`);
      if (f.hierarchy_lvl0) meta.push(f.hierarchy_lvl0);
      if (f.hierarchy_lvl1) meta.push(f.hierarchy_lvl1);
      (f.categories || []).forEach(c => meta.push(c));

      document.getElementById('modal-meta').innerHTML = meta.map(m =>
        `<span class="meta-tag">${escHtml(m)}</span>`
      ).join('');

      document.getElementById('modal-content').textContent = f.content_text || '(No content)';
      document.getElementById('modal-link').href = f.url || '#';

      document.getElementById('modal-overlay').classList.add('active');
    }

    function closeModal() {
      document.getElementById('modal-overlay').classList.remove('active');
    }

    // CSV export
    function toCSV(rows) {
      if (!rows.length) return '';
      const headers = Object.keys(rows[0]);
      const esc = v => '"' + String(v == null ? '' : v).replace(/"/g, '""') + '"';
      const out = [headers.map(esc).join(',')];
      for (const r of rows) {
        out.push(headers.map(h => esc(r[h])).join(','));
      }
      return out.join('\n');
    }

    function download(name, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/plain' }));
      a.download = name;
      a.click();
    }

    async function exportCSV() {
      if (!lastPairs.length) return alert('Run similarity analysis first');
      const rows = lastPairs.map(p => ({
        a_id: p.a.id,
        a_url: p.a.url,
        a_title: p.a.title || '',
        b_id: p.b.id,
        b_url: p.b.url,
        b_title: p.b.title || '',
        score: p.score.toFixed(3),
        tag_sim: p.tagSim.toFixed(3),
        emb_sim: p.embSim.toFixed(3)
      }));
      download('fragment_similarity.csv', toCSV(rows));
    }

    // Event listeners
    document.getElementById('modal-overlay').addEventListener('click', (e) => {
      if (e.target.id === 'modal-overlay') closeModal();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeModal();
    });

    document.getElementById('search_btn').addEventListener('click', runSearch);
    document.getElementById('search_query').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') runSearch();
    });
    document.getElementById('run').addEventListener('click', runSimilarity);
    document.getElementById('export_csv').addEventListener('click', exportCSV);

    // Initialize
    loadCategories();
  </script>
</body>
</html>
