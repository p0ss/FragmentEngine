<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>myGov - Multi-Mode Interface</title>

        <!-- Material-UI -->
        <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
        />
        <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/icon?family=Material+Icons"
        />

        <!-- React & Dependencies -->
        <script
            crossorigin
            src="https://unpkg.com/react@18/umd/react.production.min.js"
        ></script>
        <script
            crossorigin
            src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
        ></script>
        <script
            crossorigin
            src="https://unpkg.com/@mui/material@5.14.0/umd/material-ui.production.min.js"
        ></script>
        <script
            crossorigin
            src="https://unpkg.com/@babel/standalone/babel.min.js"
        ></script>
        <!-- D3.js for Journey visualization -->
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <!-- Local fallback graph data (used if API not available) -->
        <script src="data/lifevents-graph.js"></script>

        <style>
            body {
                margin: 0;
                font-family: "Roboto", sans-serif;
                background-color: #f5f5f5;
            }
            .chat-messages {
                height: 400px;
                overflow-y: auto;
                padding: 16px;
                background-color: #fafafa;
                border-radius: 4px;
                margin-bottom: 16px;
            }
            .chat-message {
                margin-bottom: 16px;
                display: flex;
                align-items: flex-start;
                gap: 8px;
            }
            .chat-message.user {
                flex-direction: row-reverse;
            }
            .chat-bubble {
                max-width: 70%;
                padding: 12px 16px;
                border-radius: 16px;
                background-color: #e0e0e0;
            }
            .chat-message.user .chat-bubble {
                background-color: #1976d2;
                color: white;
            }
            .chat-avatar {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                font-weight: 500;
            }
            .chat-message.assistant .chat-avatar {
                background-color: #66d3ee;
                color: #333;
            }
            .chat-message.user .chat-avatar {
                background-color: #1976d2;
                color: white;
            }
            .chat-message.system {
                justify-content: center;
            }
            .chat-message.system .chat-avatar {
                background-color: #ff9800;
                color: white;
                font-size: 12px;
            }
            .chat-message.system .chat-bubble {
                background-color: #fff3e0;
                border: 1px solid #ffcc02;
                color: #ef6c00;
                font-style: italic;
                font-size: 14px;
            }
            /* Markdown styling within chat messages */
            .chat-bubble strong {
                font-weight: 600;
            }
            .chat-bubble em {
                font-style: italic;
            }
            .chat-bubble a {
                color: inherit;
                text-decoration: underline;
                text-underline-offset: 2px;
            }
            .chat-bubble.user a {
                color: #e3f2fd;
            }
            .chat-bubble code {
                background-color: rgba(0, 0, 0, 0.1);
                padding: 2px 4px;
                border-radius: 3px;
                font-family: 'Courier New', monospace;
                font-size: 0.9em;
            }
            .chat-bubble.user code {
                background-color: rgba(255, 255, 255, 0.2);
            }
            .content-section {
                margin-bottom: 32px;
            }
            .content-card {
                transition: transform 0.2s;
            }
            .content-card:hover {
                transform: translateY(-2px);
            }
            .filter-chips {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                margin-bottom: 16px;
            }
            .logo-container {
                display: flex;
                align-items: center;
                gap: 12px;
            }
            .logo-image {
                height: 40px;
                width: auto;
            }
            @media print {
                .MuiAppBar-root,
                .MuiBottomNavigation-root {
                    display: none !important;
                }
            }
        </style>
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            const {
                AppBar,
                Toolbar,
                Typography,
                Container,
                Box,
                Card,
                CardContent,
                Button,
                IconButton,
                TextField,
                Chip,
                Paper,
                Grid,
                List,
                ListItem,
                ListItemText,
                ListItemIcon,
                Checkbox,
                Accordion,
                AccordionSummary,
                AccordionDetails,
                Badge,
                LinearProgress,
                ToggleButton,
                ToggleButtonGroup,
                Slider,
                Tabs,
                Tab,
                Dialog,
                DialogTitle,
                DialogContent,
                DialogActions,
                Menu,
                MenuItem,
                Snackbar,
                Alert,
                Divider,
                InputAdornment,
                Select,
                InputLabel,
                Radio,
                RadioGroup,
                FormControlLabel,
                FormControl,
                FormLabel,
                Avatar,
                Stack,
                Fade,
                Grow,
                Collapse,
                CircularProgress,
                Link,
            } = MaterialUI;

                const { useState, useEffect, useRef, useCallback } = React;

            // API Configuration
            const API_BASE_URL = location.protocol.startsWith("http")
                ? location.origin
                : "http://localhost:3000";
            const MCP_BASE_URL = location.protocol.startsWith("http")
                ? `${location.protocol}//${location.hostname}:8081`
                : "http://localhost:8081";
            const API_ENDPOINTS = {
                search: `${API_BASE_URL}/api/fragments/search`,
                facets: `${API_BASE_URL}/api/fragments/facets`,
                ollama: `${API_BASE_URL}/api/ollama/chat`,
                llm: `${API_BASE_URL}/api/llm/chat`,
                llmWithContext: `${API_BASE_URL}/api/llm/chat-with-context`,
                llmModels: `${API_BASE_URL}/api/llm/models`,
                // Journey/Profile endpoints
                journeyBuild: `${API_BASE_URL}/api/journey/profile/build`,
                journeyData: (id) => `${API_BASE_URL}/api/journey/journey/${id}`,
                journeyViz: (id) => `${API_BASE_URL}/api/journey/journey/${id}/visualization`,
            };

            // Category to Life Event mappings - FIXED TO MATCH ACTUAL API DATA
            const categoryToLifeEvents = {
                "Health and caring": [
                    "Seeking medical help",
                    "Being diagnosed with a medical condition or disability",
                    "Experiencing mental illness",
                    "Being seriously injured",
                    "Providing temporary care for another",
                    "Becoming a long term carer",
                    "Ceasing to be a carer",
                    "Experiencing the death of a loved one",
                    "Coming to the end of your life",
                    "Becoming an older Australian",
                    "Accessing aged care",
                ],
                "Family and Relationships": [
                    "Getting together",
                    "Making it work",
                    "Breaking up",
                    "Having a baby",
                    "Adopting a child",
                    "Fostering a child",
                    "Raising a child to adulthood",
                    "Separated parents",
                    "Estrangement from family",
                    "Getting a pet",
                ],
                "Work and Money": [
                    // Fixed capitalization
                    "Working",
                    "Changing careers",
                    "Returning to work",
                    "Experiencing workplace conflict",
                    "Becoming unemployed",
                    "Looking for work",
                    "Retiring from the workforce",
                    "Starting a business",
                    "Establishing trade",
                    "Growing a business",
                    "Having a business fail",
                    "Closing a business",
                    "Selling a business",
                    "Experiencing financial stress",
                ],
                "Housing and Travel": [
                    // Fixed capitalization
                    "Coming to Australia to visit",
                    "Moving to Australia permanently",
                    "Coming to Australia as a refugee",
                    "Renting a home",
                    "Buying a home",
                    "Moving into an existing household",
                    "Experiencing homelessness",
                    "Moving domestically",
                    "Moving abroad",
                    "Travelling within Australia",
                    "Travelling overseas",
                ],
                "Disasters and Crime": [
                    // Fixed capitalization
                    "Being the victim of a crime",
                    "Being arrested and charged with a crime",
                    "Being involved in a lawsuit",
                    "Being sentenced and serving your sentence",
                    "Being released from prison",
                    "Experiencing domestic violence",
                    "Leaving a violent relationship",
                    "Being removed from your family",
                    "Experiencing a war",
                    "Experiencing terrorist act",
                    "Experiencing a major industrial accident",
                    "Experiencing a pandemic",
                    "Experiencing a sudden disaster",
                    "Experiencing a gradual disaster",
                ],
                "Education and Identity": [
                    // Fixed capitalization
                    "Becoming a driver",
                    "Becoming financially independent",
                    "Moving out of home for the first time",
                    "Coming out",
                    "Changing gender identity",
                    "Changing national identity",
                    "Change in religious beliefs",
                    "Transitioning to civilian life",
                    "Studying at primary school",
                    "Studying at high school",
                    "Studying at a tertiary institution",
                    "Becoming an apprentice",
                    "Upgrading professional skills or qualifications",
                    "Coming to Australia temporarily",
                ],
            };

            function App() {
                const [mode, setMode] = useState("guided"); // browse, home, search, chat, guided
                const [expandedAccordions, setExpandedAccordions] = useState(new Set());

                // Handle accordion toggle
                const handleAccordionToggle = (accordionId) => {
                    setExpandedAccordions(prev => {
                        const newSet = new Set(prev);
                        if (newSet.has(accordionId)) {
                            newSet.delete(accordionId);
                        } else {
                            newSet.add(accordionId);
                        }
                        return newSet;
                    });
                };
                const [facetsData, setFacetsData] = useState(null);
                const [results, setResults] = useState([]);
                const [loading, setLoading] = useState(false);
                const [error, setError] = useState(null);

                // Selection state
                const [selections, setSelections] = useState({
                    category: null,
                    lifeEvent: null,
                    provider: null,
                });

                // Search state
                const [searchQuery, setSearchQuery] = useState("");
                const [searchFilters, setSearchFilters] = useState({
                    category: null,
                    lifeEvent: null,
                    provider: null,
                    state: null,
                });

                // Chat state
                const [chatMessages, setChatMessages] = useState([
                    {
                        type: "assistant",
                        text: "Hello! I'm here to help you find government services. What can I help you with today?",
                    },
                ]);
                const [chatInput, setChatInput] = useState("");
                const [ollamaModel, setOllamaModel] = useState("gemma3:27b"); // Legacy - kept for backward compat
                const [llmModel, setLlmModel] = useState("bedrock:mistral.mistral-large-2402-v1:0");
                const [availableModels, setAvailableModels] = useState([]);

                // Load available LLM models from API
                const [modelStatus, setModelStatus] = useState(null);
                const [modelRecommendations, setModelRecommendations] = useState(null);
                const [loadingModels, setLoadingModels] = useState(false);
                
                // AI Summary state
                const [aiSummary, setAiSummary] = useState(null);
                const [loadingSummary, setLoadingSummary] = useState(false);
                
                // AI Reordering state
                const [reorderedResults, setReorderedResults] = useState(null);
                const [loadingReorder, setLoadingReorder] = useState(false);
                
                // Shared Profile state (persisted across modes)
                const defaultProfile = () => ({
                    id: "user_" + Date.now(),
                    name: "Guest User",
                    age: null,
                    income: null,
                    citizenship: ["Australian"],
                    residency_state: "National",
                    employment_status: null,
                    housing_status: null,
                    has_children: false,
                    children: [],
                    is_carer: false,
                    has_disability: false,
                    current_life_events: [],
                    completed_life_events: [],
                    marital_status: null,
                    study_status: null,
                    level: 1,
                    experience_points: 0,
                });
                const [userProfile, setUserProfile] = useState(() => {
                    try {
                        const stored = localStorage.getItem('userProfile');
                        return stored ? JSON.parse(stored) : defaultProfile();
                    } catch (e) {
                        return defaultProfile();
                    }
                });
                const [profileId, setProfileId] = useState(null);
                const [profileApiError, setProfileApiError] = useState(null);
                const [guidedChatMessages, setGuidedChatMessages] = useState([]);
                const [guidedChatInput, setGuidedChatInput] = useState("");
                const [currentQuestion, setCurrentQuestion] = useState(0);
                const [isProfileComplete, setIsProfileComplete] = useState(false);
                const [matchedServices, setMatchedServices] = useState([]);
                const [loadingServices, setLoadingServices] = useState(false);
                // Chat: use local profile toggle
                const [useProfileForChat, setUseProfileForChat] = useState(() => {
                    try { return JSON.parse(localStorage.getItem('useProfileForChat') || 'true'); } catch { return true; }
                });
                useEffect(() => {
                    try { localStorage.setItem('useProfileForChat', JSON.stringify(useProfileForChat)); } catch {}
                }, [useProfileForChat]);
                
                // Journey visualization state/refs
                const journeyMapRef = useRef(null);
                const journeyFitRef = useRef(null);
                const journeyGraphMapRef = useRef({ indexById: new Map(), nodes: [] });
                const rebuildGraphRef = useRef(null);
                const [selectedEvent, setSelectedEvent] = useState(null);
                const [journeyVizData, setJourneyVizData] = useState(null);
                
                // Persist profile and sync to server recommender
                const buildServerProfile = async (p) => {
                    try {
                        const resp = await fetch(API_ENDPOINTS.journeyBuild, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(p)
                        });
                        if (!resp.ok) throw new Error(await resp.text());
                        const data = await resp.json();
                        setProfileId(data.profile_id || null);
                        setProfileApiError(null);
                    } catch (e) {
                        console.warn('Profile build failed:', e.message);
                        setProfileApiError('Recommender API unavailable — using local fallback.');
                    }
                };

                useEffect(() => {
                    try { localStorage.setItem('userProfile', JSON.stringify(userProfile)); } catch (e) {}
                    buildServerProfile(userProfile);
                }, [userProfile]);
                
                // Function to parse markdown to HTML
                const parseMarkdown = (text) => {
                    if (!text) return '';
                    
                    return text
                        // Bold text
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        // Italic text
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        // Links
                        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>')
                        // Line breaks
                        .replace(/\n/g, '<br>')
                        // Code inline
                        .replace(/`([^`]+)`/g, '<code>$1</code>');
                };

                const loadModels = async () => {
                    setLoadingModels(true);
                    try {
                        const resp = await fetch(API_ENDPOINTS.llmModels);
                        if (resp.ok) {
                            const data = await resp.json();
                            const list = data.models || [];
                            setAvailableModels(list);
                            setModelStatus(data.status);
                            setModelRecommendations(data.recommendations);
                            
                            // Select first available model if current is unavailable
                            const currentModel = list.find(m => m.value === llmModel);
                            if (!currentModel || currentModel.status !== 'available') {
                                const availableModel = list.find(m => m.status === 'available');
                                if (availableModel) {
                                    setLlmModel(availableModel.value);
                                } else if (list.length > 0) {
                                    setLlmModel(list[0].value);
                                }
                            }
                        } else {
                            throw new Error("Failed to load models");
                        }
                    } catch (e) {
                        console.warn("Falling back to default model list:", e.message);
                        const fallback = [
                            {
                                value: "bedrock:anthropic.claude-3-sonnet-20240229-v1:0",
                                label: "Bedrock • Claude 3 Sonnet",
                                provider: "bedrock",
                                status: "available"
                            }
                        ];
                        setAvailableModels(fallback);
                        setError("Could not load available models. Using default.");
                    } finally {
                        setLoadingModels(false);
                    }
                };
                
                useEffect(() => {
                    loadModels();
                }, []);

                // Generate AI summary for search results
                const generateSummary = async (searchResults) => {
                    if (!searchResults || searchResults.length === 0 || !llmModel) return;
                    
                    setLoadingSummary(true);
                    try {
                        // Prepare content for summarization
                        const resultsText = searchResults.map(result => 
                            `Title: ${result.document.title}\n` +
                            `Provider: ${result.document.provider || 'N/A'}\n` +
                            `Content: ${result.document.content_text || 'No content'}\n` +
                            `URL: ${result.document.url}`
                        ).join('\n\n---\n\n');

                        const summaryPrompt = `Please provide a concise summary of these search results. Focus on:
1. What types of information/services are covered
2. Key themes or topics
3. Which government providers are involved
4. Any patterns or connections between results

IMPORTANT: Only summarize what is provided - do not add any new information or recommendations.

Search Results:
${resultsText}`;

                        const response = await fetch(API_ENDPOINTS.llm, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                model: llmModel,
                                prompt: summaryPrompt,
                            }),
                        });

                        const data = await response.json();
                        if (response.ok) {
                            setAiSummary(data.response);
                        } else {
                            console.error('Summary generation failed:', data.error);
                        }
                    } catch (error) {
                        console.error('Summary generation error:', error);
                    } finally {
                        setLoadingSummary(false);
                    }
                };

                // Reorder content for better reading flow (Home page)
                const reorderContentForFlow = async (contentResults) => {
                    if (!contentResults || contentResults.length === 0 || !llmModel) return;
                    
                    setLoadingReorder(true);
                    try {
                        // Prepare content list with IDs and titles
                        const contentList = contentResults.map((result, index) => ({
                            id: result.id,
                            index: index,
                            title: result.title,
                            description: result.description || '',
                            category: result.category,
                            life_event: result.lifeEvent || result.life_event || 'General',
                            provider: result.provider,
                            state: result.state || 'National',
                            hierarchy: result.hierarchy || result.hierarchy_lvl0 || '',
                            relevance_score: typeof result.relevance_score === 'number' ? result.relevance_score : 0.5
                        }));

                        const reorderPrompt = `You are helping organize government information for better reading flow. 
Given the following content fragments, reorder them to create a more logical and cohesive reading experience.

IMPORTANT RULES:
1. You MUST return ONLY a JSON array of indices in the new order
2. You MUST use every index exactly once (no additions, no removals)
 3. Primary ordering key is higher "relevance_score" first (descending)
 4. Consider logical flow: general info → specific services → forms/applications → additional resources
 5. Group related topics together
 6. Prefer state-specific and provider-specific content before general content when relevant
 7. If two fragments are near-duplicates (same title or same URL), keep only the one that best fits the flow; place duplicates adjacent at the end of the list (to be filtered out by the caller)
5. DO NOT generate any new content or explanations

Content fragments:
${JSON.stringify(contentList, null, 2)}

Return ONLY a JSON array of the indices in the optimal reading order, like: [2, 0, 1, 3, ...]`;

                        const response = await fetch(API_ENDPOINTS.llm, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                model: llmModel,
                                prompt: reorderPrompt,
                            }),
                        });

                        const data = await response.json();
                        if (response.ok) {
                            try {
                                // Extract JSON array from response (handle if model adds extra text)
                                const responseText = data.response;
                                const jsonMatch = responseText.match(/\[[\d,\s]+\]/);
                                if (jsonMatch) {
                                    const newOrder = JSON.parse(jsonMatch[0]);
                                    
                                    // Validate the order array
                                    if (Array.isArray(newOrder) && 
                                        newOrder.length === contentResults.length &&
                                        new Set(newOrder).size === newOrder.length) {
                                        
                                        // Reorder the results based on AI suggestion
                                        const reordered = newOrder.map(index => contentResults[index]);
                                        setReorderedResults(reordered);
                                        return reordered;
                                    }
                                }
                            } catch (parseError) {
                                console.error('Failed to parse reorder response:', parseError);
                            }
                        }
                    } catch (error) {
                        console.error('Content reordering error:', error);
                    } finally {
                        setLoadingReorder(false);
                    }
                    
                    return null; // Return null if reordering fails
                };

                // Profile Building Questions
                const profileQuestions = [
                    {
                        id: 'age',
                        question: "Hi! I'm here to help you find the government services you're eligible for. Let's start with some basic information. How old are you?",
                        type: 'number',
                        field: 'age',
                        validation: (value) => value > 0 && value < 120,
                        followUp: (age) => age < 25 ? "Great! There are specific services available for young people." : age >= 67 ? "There are specific services for older Australians." : "Thanks!"
                    },
                    {
                        id: 'employment',
                        question: "What's your current employment status?",
                        type: 'choice',
                        field: 'employment_status',
                        options: [
                            { value: 'employed', label: 'Employed full-time' },
                            { value: 'part_time', label: 'Employed part-time' },
                            { value: 'casual', label: 'Casual employment' },
                            { value: 'unemployed', label: 'Unemployed/Looking for work' },
                            { value: 'student', label: 'Student' },
                            { value: 'retired', label: 'Retired' },
                            { value: 'self_employed', label: 'Self-employed' },
                            { value: 'unable_to_work', label: 'Unable to work due to illness/disability' }
                        ]
                    },
                    {
                        id: 'income',
                        question: "What's your approximate annual income before tax? (You can skip this if you prefer)",
                        type: 'number',
                        field: 'income',
                        optional: true,
                        prefix: '$',
                        followUp: (income) => income && income < 30000 ? "You may be eligible for low-income support services." : ""
                    },
                    {
                        id: 'housing',
                        question: "What's your housing situation?",
                        type: 'choice',
                        field: 'housing_status',
                        options: [
                            { value: 'owner', label: "I own my home" },
                            { value: 'buying', label: "I'm paying off a mortgage" },
                            { value: 'renting_private', label: 'Renting privately' },
                            { value: 'renting_public', label: 'Public/social housing' },
                            { value: 'staying_with_others', label: 'Staying with family/friends' },
                            { value: 'homeless', label: 'No fixed address/experiencing homelessness' }
                        ]
                    },
                    {
                        id: 'family',
                        question: "Do you have children under 18 living with you?",
                        type: 'boolean',
                        field: 'has_children',
                        followUpQuestion: {
                            condition: true,
                            question: "How many children do you have?",
                            type: 'number',
                            field: 'children_count'
                        }
                    },
                    {
                        id: 'carer',
                        question: "Are you a carer for someone (like a family member with disability, illness, or an elderly person)?",
                        type: 'boolean',
                        field: 'is_carer',
                        followUp: (isCarer) => isCarer ? "There are specific support services available for carers." : ""
                    },
                    {
                        id: 'disability',
                        question: "Do you have a disability or long-term health condition that affects your daily life?",
                        type: 'boolean',
                        field: 'has_disability',
                        followUp: (hasDisability) => hasDisability ? "There are support services and payments available for people with disabilities." : ""
                    },
                    {
                        id: 'life_events',
                        question: "Are you currently experiencing any of these life events?",
                        type: 'multiple_choice',
                        field: 'current_life_events',
                        options: [
                            { value: 'having_baby', label: 'Having a baby' },
                            { value: 'relationship_change', label: 'Relationship breakdown/divorce' },
                            { value: 'job_loss', label: 'Lost my job recently' },
                            { value: 'starting_work', label: 'Starting a new job' },
                            { value: 'moving_house', label: 'Moving house' },
                            { value: 'studying', label: 'Starting or continuing studies' },
                            { value: 'health_change', label: 'Significant health change' },
                            { value: 'domestic_violence', label: 'Experiencing domestic violence' },
                            { value: 'none', label: 'None of these apply to me' }
                        ]
                    }
                ];

                // Initialize chat with first question
                useEffect(() => {
                    if (mode === "guided" && guidedChatMessages.length === 0) {
                        setGuidedChatMessages([{
                            type: 'assistant',
                            text: profileQuestions[0].question,
                            id: `msg-${Date.now()}`
                        }]);
                    }
                }, [mode]);

                // Handle chat responses and profile building
                const handleChatResponse = (response) => {
                    const question = profileQuestions[currentQuestion];
                    if (!question) return;

                    // Add user message
                    const userMessage = {
                        type: 'user',
                        text: response,
                        id: `msg-${Date.now()}`
                    };
                    
                    // Update profile
                    const updatedProfile = { ...userProfile };
                    
                    if (question.type === 'choice' || question.type === 'boolean') {
                        updatedProfile[question.field] = response;
                    } else if (question.type === 'number') {
                        updatedProfile[question.field] = parseInt(response);
                    } else if (question.type === 'multiple_choice') {
                        updatedProfile[question.field] = Array.isArray(response) ? response : [response];
                    }

                    setUserProfile(updatedProfile);
                    
                    // Generate assistant response
                    let assistantText = "";
                    if (question.followUp && typeof question.followUp === 'function') {
                        assistantText = question.followUp(response);
                    }
                    
                    // Move to next question
                    const nextQuestionIndex = currentQuestion + 1;
                    
                    if (nextQuestionIndex < profileQuestions.length) {
                        if (assistantText) {
                            assistantText += " ";
                        }
                        assistantText += profileQuestions[nextQuestionIndex].question;
                        setCurrentQuestion(nextQuestionIndex);
                    } else {
                        // Profile complete
                        if (assistantText) {
                            assistantText += " ";
                        }
                        assistantText += "Perfect! I've gathered all the information I need. Let me find services that match your situation...";
                        setIsProfileComplete(true);
                        setTimeout(() => matchServices(updatedProfile), 1000);
                    }

                    const assistantMessage = {
                        type: 'assistant',
                        text: assistantText,
                        id: `msg-${Date.now() + 1}`
                    };

                    setGuidedChatMessages(prev => [...prev, userMessage, assistantMessage]);
                };

                // Match services based on profile
                const matchServices = async (profile) => {
                    setLoadingServices(true);
                    
                    // Build broader category-based search criteria (more flexible approach)
                    const relevantCategories = new Set();
                    
                    // Age-based categories
                    if (profile.age < 25) {
                        relevantCategories.add("Education and identity");
                        relevantCategories.add("Work and Money");
                    } else if (profile.age >= 67) {
                        relevantCategories.add("Health and caring");
                    }

                    // Employment-based categories
                    if (profile.employment_status === 'unemployed' || profile.employment_status === 'student') {
                        relevantCategories.add("Work and Money");
                    }

                    // Family-based categories
                    if (profile.has_children) {
                        relevantCategories.add("Family and Relationships");
                    }

                    // Housing-based categories
                    if (profile.housing_status === 'homeless' || profile.housing_status === 'renting_private') {
                        relevantCategories.add("Housing and Travel");
                    }

                    // Disability/health-based categories
                    if (profile.has_disability) {
                        relevantCategories.add("Health and caring");
                    }

                    // Carer-based categories
                    if (profile.is_carer) {
                        relevantCategories.add("Health and caring");
                        relevantCategories.add("Family and Relationships");
                    }

                    // Life event categories
                    if (profile.current_life_events && profile.current_life_events.length > 0) {
                        profile.current_life_events.forEach(event => {
                            if (event === 'having_baby') {
                                relevantCategories.add("Family and Relationships");
                            } else if (event === 'job_loss' || event === 'starting_work') {
                                relevantCategories.add("Work and Money");
                            } else if (event === 'health_change') {
                                relevantCategories.add("Health and caring");
                            } else if (event === 'moving_house') {
                                relevantCategories.add("Housing and Travel");
                            } else if (event === 'studying') {
                                relevantCategories.add("Education and identity");
                            } else if (event === 'relationship_change') {
                                relevantCategories.add("Family and Relationships");
                            }
                        });
                    }

                    // If no specific criteria, include basic categories everyone might need
                    if (relevantCategories.size === 0) {
                        relevantCategories.add("Health and caring");
                        relevantCategories.add("Work and Money");
                    }

                    // Search for services in each relevant category
                    let allServices = [];
                    
                    try {
                        for (const category of Array.from(relevantCategories)) {
                            const params = new URLSearchParams({
                                q: "*",
                                include_html: "true",
                                per_page: "15", // Get more results per category
                            });

                            params.append("category", category);

                            const response = await fetch(`${API_ENDPOINTS.search}?${params}`);
                            if (response.ok) {
                                const data = await response.json();
                                console.log(`Search results for category "${category}":`, data.found, 'results found');
                                if (data.results) {
                                    // Process each result and add eligibility scoring
                                    const processedResults = data.results.map((hit) => ({
                                        id: hit.document.id,
                                        url: hit.document.url,
                                        title: hit.document.title,
                                        description: hit.document.content_text,
                                        content_html: hit.document.content_html,
                                        category: hit.document.categories?.[0] || category,
                                        lifeEvent: hit.document.life_events?.[0] || "General",
                                        provider: hit.document.provider || "Services Australia",
                                        state: hit.document.states?.[0] || "National",
                                        document: hit.document,
                                        // Add eligibility scoring
                                        eligibility_score: calculateEligibilityScore(hit.document, profile),
                                        match_reason: getMatchReason(hit.document, profile, { category })
                                    }));
                                    
                                    allServices.push(...processedResults);
                                }
                            }
                        }

                        // Remove duplicates and sort by score
                        const uniqueServices = allServices.filter((service, index, self) => 
                            index === self.findIndex(s => s.id === service.id)
                        );
                        
                        const topServices = uniqueServices
                            .sort((a, b) => b.eligibility_score - a.eligibility_score)
                            .slice(0, 8);

                        console.log('Matched services:', topServices);
                        console.log('First service details:', topServices[0]);
                        setMatchedServices(topServices);

                        // Add completion message
                        const completionMessage = {
                            type: 'assistant',
                            text: `Great! I found ${topServices.length} services that match your situation. These are personalized recommendations based on your profile.`,
                            id: `msg-${Date.now()}`
                        };
                        setGuidedChatMessages(prev => [...prev, completionMessage]);

                    } catch (error) {
                        console.error('Error matching services:', error);
                        const errorMessage = {
                            type: 'assistant',
                            text: "I encountered an issue finding services. Please try again or use the Browse mode to explore available services.",
                            id: `msg-${Date.now()}`
                        };
                        setGuidedChatMessages(prev => [...prev, errorMessage]);
                    }

                    setLoadingServices(false);
                };

                // Calculate eligibility score based on profile
                const calculateEligibilityScore = (service, profile) => {
                    let score = 0.5; // Base score

                    // Age matching
                    if (service.title && profile.age) {
                        if (profile.age < 25 && (service.title.toLowerCase().includes('youth') || service.title.toLowerCase().includes('young'))) {
                            score += 0.3;
                        } else if (profile.age >= 67 && (service.title.toLowerCase().includes('age') || service.title.toLowerCase().includes('pension'))) {
                            score += 0.3;
                        }
                    }

                    // Employment matching
                    if (profile.employment_status === 'unemployed' && service.title && 
                        (service.title.toLowerCase().includes('job') || service.title.toLowerCase().includes('work') || service.title.toLowerCase().includes('seek'))) {
                        score += 0.2;
                    }

                    // Family matching
                    if (profile.has_children && service.title &&
                        (service.title.toLowerCase().includes('family') || service.title.toLowerCase().includes('child') || service.title.toLowerCase().includes('parent'))) {
                        score += 0.2;
                    }

                    return Math.min(score, 1.0);
                };

                // Get human-readable match reason
                const getMatchReason = (service, profile, criterion) => {
                    const reasons = [];
                    
                    if (criterion.life_event) {
                        reasons.push(`Relevant for: ${criterion.life_event}`);
                    }
                    if (profile.employment_status === 'unemployed') {
                        reasons.push("Job seeker support");
                    }
                    if (profile.has_children) {
                        reasons.push("Family support");
                    }
                    if (profile.age < 25) {
                        reasons.push("Youth services");
                    }
                    if (profile.age >= 67) {
                        reasons.push("Senior services");
                    }

                    return reasons.length > 0 ? reasons.join(", ") : "General eligibility";
                };

                // Guided Mode: Get AI-suggested filter options using MCP
                const getGuidedOptions = async (currentProfile = {}) => {
                    setLoadingGuidedOptions(true);
                    try {
                        // Use MCP server directly to analyze filter combinations
                        const response = await fetch(`${MCP_BASE_URL}/analyze-combinations`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                existing_filters: currentProfile,
                                max_options: 6
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            console.log('MCP Analysis result:', data);
                            
                            // Convert MCP suggestions to UI options
                            const mcpOptions = data.suggestions || [];
                            const uiOptions = mcpOptions.map((suggestion, index) => ({
                                id: `${suggestion.type}-${index}`,
                                label: suggestion.label,
                                description: suggestion.description,
                                type: suggestion.type,
                                value: suggestion.value,
                                count: suggestion.count
                            }));
                            
                            setGuidedOptions(uiOptions);
                        } else {
                            throw new Error(`MCP server error: ${response.status}`);
                        }
                    } catch (error) {
                        console.error('Error getting guided options from MCP:', error);
                        
                        // Fallback: Use real Typesense facets instead of made-up options
                        try {
                            const facetsResponse = await fetch(API_ENDPOINTS.facets);
                            if (facetsResponse.ok) {
                                const facetsData = await facetsResponse.json();
                                console.log('Facets data structure:', facetsData);
                                let fallbackOptions = [];
                                
                                if (!currentProfile.category) {
                                    // Show real categories from Typesense (it's an array, not object)
                                    fallbackOptions = (facetsData.categories || []).slice(0, 6).map((cat) => ({
                                        id: cat.value.toLowerCase().replace(/\s+/g, '-'),
                                        label: cat.value,
                                        type: 'category',
                                        value: cat.value,
                                        description: `${cat.count} results available`,
                                        count: cat.count
                                    }));
                                } else if (!currentProfile.life_event) {
                                    // Show real life events from Typesense (it's an array, not object)
                                    // Filter life events for the selected category like the working Browse mode does
                                    const allowedEvents = categoryToLifeEvents[currentProfile.category] || [];
                                    const filteredLifeEvents = facetsData.life_events
                                        ?.filter((event) => allowedEvents.includes(event.value))
                                        ?.sort((a, b) => b.count - a.count) || [];
                                    
                                    fallbackOptions = filteredLifeEvents.slice(0, 6).map((event) => ({
                                        id: event.value.toLowerCase().replace(/\s+/g, '-'),
                                        label: event.value,
                                        type: 'life_event',
                                        value: event.value,
                                        description: `${event.count} results for this situation`,
                                        count: event.count
                                    }));
                                    
                                    // If no category-specific life events, show top general ones
                                    if (fallbackOptions.length === 0) {
                                        fallbackOptions = (facetsData.life_events || []).slice(0, 6).map((event) => ({
                                            id: event.value.toLowerCase().replace(/\s+/g, '-'),
                                            label: event.value,
                                            type: 'life_event',
                                            value: event.value,
                                            description: `${event.count} results for this situation`,
                                            count: event.count
                                        }));
                                    }
                                } else {
                                    // Show real providers from Typesense (it's an array, not object)
                                    fallbackOptions = (facetsData.providers || []).slice(0, 4).map((provider) => ({
                                        id: provider.value.toLowerCase().replace(/\s+/g, '-'),
                                        label: provider.value,
                                        type: 'provider',
                                        value: provider.value,
                                        description: `${provider.count} results from this provider`,
                                        count: provider.count
                                    }));
                                }
                                
                                setGuidedOptions(fallbackOptions);
                            } else {
                                // Ultimate fallback - minimal hardcoded options
                                setGuidedOptions([
                                    { id: 'family', label: 'Family and relationships', type: 'category', value: 'Family and relationships', description: 'Family results' },
                                    { id: 'health', label: 'Health and caring', type: 'category', value: 'Health and caring', description: 'Health results' },
                                    { id: 'work', label: 'Work and Money', type: 'category', value: 'Work and Money', description: 'Employment and financial results' }
                                ]);
                            }
                        } catch (facetsError) {
                            console.error('Error loading facets for fallback:', facetsError);
                            setGuidedOptions([]);
                        }
                    }
                    setLoadingGuidedOptions(false);
                };

                // Load and filter results for guided mode
                const loadGuidedResults = async (profile) => {
                    console.log('Loading guided results for profile:', profile);
                    setLoading(true);
                    setError(null);
                    setResults([]);
                    setReorderedResults(null);

                    try {
                        const params = new URLSearchParams({
                            q: "*", // Get all content
                            include_html: "true",
                            per_page: "100",
                            sort_by: 'srrs_score:desc,popularity_sort:asc'
                        });

                        // Add filters based on guided profile
                        // Note: Use snake_case like Browse mode (life_event not lifeEvent)
                        if (profile.category) {
                            params.append("category", profile.category);
                        }
                        if (profile.life_event) {
                            params.append("life_event", profile.life_event); // Use snake_case like Browse mode
                        }
                        if (profile.provider && profile.provider !== "All providers") {
                            params.append("provider", profile.provider);
                        }
                        if (profile.state && profile.state !== "All states") {
                            params.append("state", profile.state);
                        }

                        const apiUrl = `${API_ENDPOINTS.search}?${params}`;
                        console.log('API URL:', apiUrl);
                        const response = await fetch(apiUrl);
                        
                        if (!response.ok) {
                            throw new Error("Failed to load results");
                        }

                        const data = await response.json();
                        console.log('API response data:', data);
                        
                        const filteredResults = (data.results || []);

                        console.log('Total results from API:', data.results.length);
                        console.log('Filtered results:', filteredResults.length);
                        console.log('Sample results:', filteredResults.slice(0, 3).map(r => ({ 
                            title: r.title, 
                            desc: r.description?.substring(0, 100),
                            content_html: r.content_html ? 'HAS HTML' : 'NO HTML',
                            url: r.url 
                        })));
                        console.log('Full first result:', filteredResults[0]);

                        // Process results similar to the normal loadResults function
                        const processedResults = filteredResults.map((item) => ({
                            id: item.id,
                            title: item.title,
                            description: item.description,
                            content_html: item.content_html,
                            url: item.url,
                            category: item.category,
                            life_event: item.life_event || "General",
                            provider: item.provider || "Services Australia",
                            state: item.state || "National",
                            hierarchy: item.hierarchy_lvl0 || item.title,
                            document: item
                        }));

                        let cleaned = filterAndDedupe(processedResults, profile);
                        cleaned = computeRelevanceScores(cleaned, profile)
                            .sort((a, b) => (b.relevance_score || 0) - (a.relevance_score || 0));
                        setResults(cleaned);

                        // Apply AI reordering for guided mode (same as home mode)
                        if (cleaned.length > 0) {
                            reorderContentForFlow(cleaned);
                        }

                    } catch (error) {
                        console.error('Error loading guided results:', error);
                        setError("Failed to load personalized results. Please try again.");
                    } finally {
                        setLoading(false);
                    }
                };

                // Load a personalized Home view based on local profile (non‑generative ordering)
                const loadPersonalizedHome = async (profile) => {
                    try {
                        setMode('home');
                        setLoading(true);
                        setError(null);
                        setResults([]);
                        setReorderedResults(null);

                        const params = new URLSearchParams({ q: '*', include_html: 'true', per_page: '100', sort_by: 'srrs_score:desc,popularity_sort:asc' });
                        // Derive filters from profile
                        if (Array.isArray(profile.current_life_events) && profile.current_life_events.length > 0) {
                            params.append('life_event', profile.current_life_events[0]);
                        }
                        if (profile.residency_state && profile.residency_state !== 'National' && profile.residency_state !== 'All states') {
                            params.append('state', profile.residency_state);
                        }
                        if (profile.provider && profile.provider !== 'All providers') {
                            params.append('provider', profile.provider);
                        }

                        const response = await fetch(`${API_ENDPOINTS.search}?${params.toString()}`);
                        if (!response.ok) throw new Error('Failed to load personalized content');
                        const data = await response.json();

                        const processed = (data.results || []).map((hit) => ({
                            id: hit.document.id,
                            url: hit.document.url,
                            title: hit.document.title,
                            description: hit.document.content_text,
                            content_html: hit.document.content_html,
                            category: hit.document.categories?.[0] || 'General Information',
                            lifeEvent: hit.document.life_events?.[0] || 'General',
                            provider: hit.document.provider || 'Services Australia',
                            state: hit.document.states?.[0] || 'National',
                            hierarchy: hit.document.hierarchy_lvl0 || hit.document.title,
                            document: hit.document,
                            eligibility_score: calculateEligibilityScore(hit.document, profile),
                        }));

                        let curated = filterAndDedupe(processed, profile);
                        curated = computeRelevanceScores(curated, profile)
                            .sort((a, b) => (b.relevance_score || 0) - (a.relevance_score || 0));

                        setResults(curated);
                        if (curated.length > 0) {
                            reorderContentForFlow(curated);
                        }
                    } catch (e) {
                        console.error('Personalized home error:', e);
                        setError('Failed to load personalized home.');
                    } finally {
                        setLoading(false);
                    }
                };

                // Progress tracking
                const [completedTasks, setCompletedTasks] = useState([]);

                // Export menu
                const [exportAnchor, setExportAnchor] = useState(null);

                // Load facets on mount
                useEffect(() => {
                    loadFacets();
                }, []);

                // Load results when selections change
                useEffect(() => {
                    if (mode === "browse" || mode === "home") {
                        if (
                            selections.category &&
                            selections.lifeEvent &&
                            selections.provider
                        ) {
                            loadResults();
                        }
                    }
                }, [selections, mode]);

                // Note: Old guided options useEffect removed - now using chat-based approach

                const loadFacets = async () => {
                    try {
                        const response = await fetch(API_ENDPOINTS.facets);
                        if (!response.ok)
                            throw new Error("Failed to load facets");
                        const data = await response.json();
                        setFacetsData(data);
                    } catch (err) {
                        setError(
                            "Failed to load options. Please check if the API is running.",
                        );
                        console.error(err);
                    }
                };

                // Utility: filter and deduplicate fragments
                const filterAndDedupe = (items, profile = null) => {
                    const seen = new Set();
                    const badTitleKeywords = [
                        'footer','navigation','menu','header','sign in','signin','log in','login','search','breadcrumbs','privacy','terms','skip to','print','share','site map','sitemap','cookie','javascript','captcha'
                    ];
                    const badUrlPatterns = [/\/search(\?|$)/i, /\/sitemap/i, /\/404/i];
                    const badEvents = [/pandemic/i, /covid/i, /coronavirus/i];
                    const veteranEvents = [/civilian/i, /veteran/i, /military/i];
                    const profEvents = Array.isArray(profile?.current_life_events) ? profile.current_life_events.join(' ').toLowerCase() : '';

                    const isBadByTitle = (t) => {
                        const title = (t || '').toLowerCase().trim();
                        return badTitleKeywords.some(k => title.includes(k));
                    };
                    const isBadByUrl = (u) => {
                        const url = String(u || '');
                        return badUrlPatterns.some(rx => rx.test(url));
                    };
                    const isBadByLifeEvent = (ev) => {
                        const e = (ev || '').toLowerCase();
                        if (badEvents.some(rx => rx.test(e))) return true; // hide pandemic/covid
                        // hide veteran/civilian if profile not related
                        if (veteranEvents.some(rx => rx.test(e)) && !/veteran|military|defence|defense/.test(profEvents)) return true;
                        return false;
                    };

                    const out = [];
                    for (const it of items) {
                        const key = (it.url || it.id || it.title || '') + '|' + (it.title || '');
                        if (seen.has(key)) continue;
                        if (!it.title && !it.description && !it.content_html) continue;
                        if (isBadByTitle(it.title) || isBadByTitle(it.hierarchy)) continue;
                        if (isBadByUrl(it.url)) continue;
                        if (isBadByLifeEvent(it.lifeEvent || it.life_event)) continue;
                        seen.add(key);
                        out.push(it);
                    }
                    return out;
                };

                // Holmes & Rahe Social Readjustment Rating Scale (SRRS) → evidence-based weighting
                // Values roughly aligned to the original scale; mapped to our event taxonomy
                const SRRS_WEIGHTS = {
                    // Relationship / family
                    'death of spouse': 100,
                    'divorce': 73,
                    'marital separation': 65,
                    'death of close family member': 63,
                    'marriage': 50,
                    'marital reconciliation': 45,
                    'pregnancy': 40,
                    'gain a new family member': 39,
                    'child leaving home': 29,
                    
                    // Health
                    'personal injury or illness': 53,
                    'change in health of family member': 44,
                    
                    // Work & money
                    'dismissal from work': 47,
                    'retirement': 45,
                    'business readjustment': 39,
                    'change in financial state': 38,
                    'change to a different line of work': 36,
                    'trouble with boss': 23,
                    'change in work hours or conditions': 20,
                    
                    // Housing / residence / schooling
                    'change in living conditions': 25,
                    'change in residence': 20,
                    'start or end school': 26,
                };

                const mapEventToSRRS = (name) => {
                    if (!name) return 0;
                    const n = String(name).toLowerCase();
                    // Direct keyword mapping (order matters: pick the highest/severest category first)
                    if (/(death of (a )?spouse|widow|widower)/.test(n)) return SRRS_WEIGHTS['death of spouse'];
                    if (/(divorce|relationship breakdown)/.test(n)) return SRRS_WEIGHTS['divorce'];
                    if (/(separation|separated)/.test(n)) return SRRS_WEIGHTS['marital separation'];
                    if (/(death of (close )?family|death of someone close|bereavement)/.test(n)) return SRRS_WEIGHTS['death of close family member'];
                    if (/(pregnancy|having a baby|newborn)/.test(n)) return Math.max(SRRS_WEIGHTS['pregnancy'], SRRS_WEIGHTS['gain a new family member']);
                    if (/(new family member|adopt)/.test(n)) return SRRS_WEIGHTS['gain a new family member'];
                    if (/(injury|illness|diagnosed|health change|serious injury|disability|mental illness)/.test(n)) return SRRS_WEIGHTS['personal injury or illness'];
                    if (/(carer|care for|caring)/.test(n)) return SRRS_WEIGHTS['change in health of family member'];
                    if (/(job loss|lost my job|dismissal|redundant|unemploy)/.test(n)) return SRRS_WEIGHTS['dismissal from work'];
                    if (/(start(ing)? work|new job|work hours|work conditions)/.test(n)) return Math.max(SRRS_WEIGHTS['change in work hours or conditions'], SRRS_WEIGHTS['change to a different line of work']);
                    if (/(change (of|in) (career|line of work)|career change)/.test(n)) return SRRS_WEIGHTS['change to a different line of work'];
                    if (/(moving house|move house|relocat|change of address|change in residence)/.test(n)) return SRRS_WEIGHTS['change in residence'];
                    if (/(housing|living conditions|homeless|no fixed address)/.test(n)) return SRRS_WEIGHTS['change in living conditions'];
                    if (/(start(ing)? school|end(ing)? school|university|study)/.test(n)) return SRRS_WEIGHTS['start or end school'];
                    return 0;
                };

                // Utility: compute relevance scores per fragment based on SRRS and profile alignment
                const computeRelevanceScores = (items, profile = {}) => {
                    const p = profile || {};
                    const age = p.age;
                    const emp = (p.employment_status || '').toLowerCase();
                    const housing = (p.housing_status || '').toLowerCase();
                    const state = (p.residency_state || 'National');
                    const lifeEvents = Array.isArray(p.current_life_events) ? p.current_life_events.map(e=>String(e).toLowerCase()) : [];

                    const textFor = (it) => ((it.title || '') + ' ' + (it.description || '')).toLowerCase();

                    return items.map((it) => {
                        // SRRS base (0..1). Try explicit lifeEvent first, then text heuristics.
                        const events = [];
                        if (it.lifeEvent) events.push(it.lifeEvent);
                        if (it.life_event) events.push(it.life_event);
                        if (Array.isArray(it.document?.life_events)) events.push(...it.document.life_events);
                        let srrsRaw = 0;
                        for (const ev of events) {
                            srrsRaw = Math.max(srrsRaw, mapEventToSRRS(ev));
                        }
                        if (srrsRaw === 0) {
                            srrsRaw = mapEventToSRRS(textFor(it));
                        }
                        let score = (srrsRaw / 100) || 0.4; // default modest base

                        const txt = textFor(it);
                        // Profile alignment boosts (smaller than SRRS base)
                        // Employment
                        if (emp === 'unemployed' || emp === 'unable_to_work') {
                            if (/job|employment|jobseeker|income support|unemploy|seeker|workforce/.test(txt)) score += 0.15;
                            if (/payment|allowance|benefit|centrelink/.test(txt)) score += 0.1;
                        }

                        // Housing
                        if (housing === 'homeless' || housing === 'renting_public' || housing === 'renting_private') {
                            if (/housing|rent|accommodation|homeless|public housing|tenancy/.test(txt)) score += 0.15;
                            if (/crisis|emergency|support service/.test(txt)) score += 0.1;
                        }

                        // Age
                        if (typeof age === 'number') {
                            if (age < 30 && /(youth|young|apprentice|trainee|graduate)/.test(txt)) score += 0.1;
                            if (age >= 67 && /(age pension|retirement|senior)/.test(txt)) score += 0.15;
                        }

                        // Life event alignment
                        if (lifeEvents.length > 0) {
                            const ev = lifeEvents[0];
                            if (ev && it.lifeEvent && String(it.lifeEvent).toLowerCase().includes(ev)) score += 0.2;
                        }

                        // State- and provider-specific (more actionable)
                        if (it.state && it.state !== 'National') score += 0.1;
                        if (it.provider && it.provider !== 'Services Australia') score += 0.05;

                        // Down-weights for known off-topic areas (kept after earlier filtering, just in case)
                        if (/pandemic|covid|coronavirus/.test(txt)) score -= 0.5;
                        if (/civilian|veteran|military/.test(txt) && !/(veteran|military|defence|defense)/.test(lifeEvents.join(' '))) score -= 0.3;

                        // Clamp
                        if (score > 1) score = 1;
                        if (score < 0) score = 0;

                        return { ...it, relevance_score: score };
                    });
                };

                const loadResults = async (searchParams = {}) => {
                    setLoading(true);
                    setError(null);

                    try {
                        const params = new URLSearchParams({
                            q: searchParams.q || "*",
                            include_html: "true",
                            per_page: "100",
                            sort_by: 'srrs_score:desc,popularity_sort:asc'
                        });

                        // Add filters based on mode
                        if (mode === "browse" || mode === "home") {
                            if (selections.category)
                                params.append("category", selections.category);
                            if (selections.lifeEvent)
                                params.append(
                                    "life_event",
                                    selections.lifeEvent,
                                );
                            if (
                                selections.provider &&
                                selections.provider !== "All providers"
                            ) {
                                params.append("provider", selections.provider);
                            }
                        } else if (mode === "search") {
                            if (searchFilters.category)
                                params.append(
                                    "category",
                                    searchFilters.category,
                                );
                            if (searchFilters.lifeEvent)
                                params.append(
                                    "life_event",
                                    searchFilters.lifeEvent,
                                );
                            if (searchFilters.provider)
                                params.append(
                                    "provider",
                                    searchFilters.provider,
                                );
                            if (searchFilters.state)
                                params.append("state", searchFilters.state);
                        }

                        const response = await fetch(
                            `${API_ENDPOINTS.search}?${params}`,
                        );
                        if (!response.ok) throw new Error("Failed to search");
                        const data = await response.json();

                        const processedResults = data.results.map((hit) => ({
                            id: hit.document.id,
                            url: hit.document.url,
                            title: hit.document.title,
                            description: hit.document.content_text,
                            content_html: hit.document.content_html,
                            category:
                                hit.document.categories?.[0] || "General",
                            lifeEvent:
                                hit.document.life_events?.[0] || "General",
                            provider:
                                hit.document.provider ||
                                "Services Australia",
                            state: hit.document.states?.[0] || "National",
                            hierarchy:
                                hit.document.hierarchy_lvl0 ||
                                hit.document.title,
                            document: hit.document // Keep original document for summary
                        }));
                        // Filter and deduplicate generic non-content items
                        let cleaned = filterAndDedupe(processedResults, userProfile);
                        // Score and sort by relevance so groups inherit top item priority
                        cleaned = computeRelevanceScores(cleaned, userProfile)
                            .sort((a, b) => (b.relevance_score || 0) - (a.relevance_score || 0));
                        setResults(cleaned);
                        
                        // Generate AI summary for search mode
                        if (mode === "search" && data.results.length > 0) {
                            setAiSummary(null); // Clear previous summary
                            generateSummary(data.results);
                        }
                        
                        // Reorder content for home mode
                        if (mode === "home" && cleaned.length > 0) {
                            setReorderedResults(null); // Clear previous reordering
                            reorderContentForFlow(cleaned);
                        }
                    } catch (err) {
                        setError("Failed to load results. Please try again.");
                        console.error(err);
                    } finally {
                        setLoading(false);
                    }
                };

                const handleSearch = () => {
                    loadResults({ q: searchQuery });
                };

                const handleChatSend = async () => {
                    if (!chatInput.trim()) return;

                    const userMessage = chatInput;
                    setChatInput("");

                    // Add user message
                    setChatMessages((prev) => [
                        ...prev,
                        { type: "user", text: userMessage },
                    ]);

                    // Add a loading message
                    const loadingId = Date.now();
                    setChatMessages((prev) => [
                        ...prev,
                        {
                            type: "assistant",
                            text: "Thinking...",
                            id: loadingId,
                            loading: true,
                        },
                    ]);

                    try {
                        // First, search for relevant content using Typesense
                        const searchResponse = await fetch(
                            `${API_ENDPOINTS.search}?${new URLSearchParams({
                                q: userMessage,
                                per_page: "5",
                                include_html: "false",
                            })}`,
                        );

                        let context = "";
                        if (searchResponse.ok) {
                            const searchData = await searchResponse.json();
                            context = searchData.results
                                .map(
                                    (hit) =>
                                        `Title: ${hit.document.title}\nContent: ${hit.document.content_text}\nProvider: ${hit.document.provider}`,
                                )
                                .join("\n\n---\n\n");
                        }

                        // Prepare the prompt with context
                        const systemPrompt = `You are a helpful Australian government services assistant. Use the following search results to answer the user's question. If the search results don't contain relevant information, provide general guidance and suggest where they might find more information.

Search Results:
${context || "No specific results found for this query."}

Remember to:
- Be helpful and concise
- Reference specific services or providers when mentioned in the search results
- Suggest visiting official government websites for the most up-to-date information
- If discussing eligibility or requirements, note that these can vary and users should check official sources`;

                        const fullPrompt = `${systemPrompt}\n\nUser: ${userMessage}\n\nAssistant:`;

                        console.log("Using MCP-powered context-aware chat with model:", llmModel);

                        // Add progress indicator message
                        const searchingId = `searching-${Date.now()}`;
                        setChatMessages((prev) => [
                            ...prev,
                            {
                                type: "system",
                                text: "🔍 Searching government information database...",
                                id: searchingId,
                                timestamp: new Date().toLocaleTimeString(),
                            },
                        ]);

                        // Small delay to ensure searching message is visible
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // Prepare optional user profile context
                        const profileForContext = (() => {
                            const p = userProfile || {};
                            const meaningful = {
                                age: p.age || null,
                                income: p.income || null,
                                residency_state: p.residency_state || null,
                                employment_status: p.employment_status || null,
                                housing_status: p.housing_status || null,
                                has_children: !!p.has_children,
                                is_carer: !!p.is_carer,
                                has_disability: !!p.has_disability,
                                current_life_events: Array.isArray(p.current_life_events) ? p.current_life_events : [],
                            };
                            // Determine if any field is actually set beyond defaults
                            const defaults = {
                                age: null,
                                income: null,
                                residency_state: 'National',
                                employment_status: null,
                                housing_status: null,
                                has_children: false,
                                is_carer: false,
                                has_disability: false,
                                current_life_events: [],
                            };
                            const anySet = Object.keys(meaningful).some(k => {
                                const a = meaningful[k];
                                const b = defaults[k];
                                if (Array.isArray(a) && Array.isArray(b)) return a.length > 0;
                                return a !== b && a !== undefined && a !== '';
                            });
                            return anySet ? meaningful : null;
                        })();

                        // Call MCP-powered context-aware endpoint  
                        const response = await fetch(API_ENDPOINTS.llmWithContext, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                model: llmModel,
                                prompt: userMessage, // Use original user message, not fullPrompt
                                search_options: {
                                    per_page: 5
                                },
                                user_profile: (useProfileForChat && profileForContext) ? profileForContext : null
                            }),
                        });

                        // Update searching message to show completion
                        setChatMessages((prev) => 
                            prev.map(msg => 
                                msg.id === searchingId 
                                    ? { ...msg, text: "✅ Search completed, generating response..." }
                                    : msg
                            )
                        );

                        // Small delay to show completion message
                        await new Promise(resolve => setTimeout(resolve, 300));

                        const data = await response.json();

                        if (!response.ok) {
                            throw new Error(
                                data.error ||
                                    `Server returned ${response.status}`,
                            );
                        }

                        // Show sources found (if any)
                        if (data.context && data.context.results_found > 0) {
                            const sourcesId = `sources-${Date.now()}`;
                            setChatMessages((prev) => [
                                ...prev.filter(msg => msg.id !== loadingId && msg.id !== searchingId), // Remove loading and searching messages
                                {
                                    type: "system",
                                    text: `✅ Found ${data.context.results_found} relevant result(s)`,
                                    id: sourcesId,
                                    timestamp: new Date().toLocaleTimeString(),
                                    sources: data.context.sources
                                },
                                {
                                    type: "assistant",
                                    text: data.response,
                                    id: loadingId,
                                    context: data.context
                                }
                            ]);
                        } else {
                            // Replace loading message with actual response (no context found)
                            setChatMessages((prev) =>
                                prev.filter(msg => msg.id !== searchingId) // Remove searching message
                                    .map((msg) =>
                                        msg.id === loadingId
                                            ? {
                                                  type: "assistant",
                                                  text: data.response,
                                                  id: loadingId,
                                                  context: data.context || null
                                              }
                                            : msg,
                                    ),
                            );
                        }
                    } catch (error) {
                        console.error("Chat error:", error);

                        let errorMessage = "Sorry, I encountered an error. ";
                        let suggestion = null;

                        if (error.message.includes("Failed to fetch")) {
                            errorMessage +=
                                "Could not connect to the API server. Please ensure the API is running on port 3000.";
                        } else {
                            // Try to parse structured error from API
                            try {
                                const errorData = JSON.parse(error.message);
                                errorMessage += errorData.error || error.message;
                                suggestion = errorData.suggestion;
                            } catch {
                                // Handle direct API errors with structured response
                                if (response && !response.ok) {
                                    const errorData = await response.json();
                                    errorMessage += errorData.error || error.message;
                                    suggestion = errorData.suggestion;
                                } else {
                                    // Fallback to basic error handling
                                    if (error.message.includes("404") || error.message.toLowerCase().includes("model")) {
                                        errorMessage += "Model not available. Please select a different model or check Bedrock configuration.";
                                    } else {
                                        errorMessage += error.message;
                                    }
                                }
                            }
                        }

                        // Replace loading message with error message and remove searching message
                        setChatMessages((prev) =>
                            prev.filter(msg => msg.id !== searchingId) // Remove searching message
                                .map((msg) =>
                                    msg.id === loadingId
                                        ? {
                                              type: "assistant",
                                              text: errorMessage + (suggestion ? `\n\n💡 Suggestion: ${suggestion}` : ''),
                                              id: loadingId,
                                              error: true,
                                          }
                                        : msg,
                                ),
                        );
                    }
                };

                const toggleTask = (taskId) => {
                    setCompletedTasks((prev) => {
                        if (prev.includes(taskId)) {
                            return prev.filter((id) => id !== taskId);
                        } else {
                            return [...prev, taskId];
                        }
                    });
                };

                const progress =
                    results.length > 0
                        ? (completedTasks.length / results.length) * 100
                        : 0;

                // ADD FILTERING HELPER FUNCTIONS
                const getFilteredLifeEvents = () => {
                    const selectedCategory =
                        mode === "search"
                            ? searchFilters.category
                            : selections.category;
                    if (!selectedCategory || !facetsData?.life_events)
                        return [];

                    // Get allowed life events for selected category
                    const allowedEvents =
                        categoryToLifeEvents[selectedCategory] || [];

                    // Filter facets data to only include allowed events
                    return facetsData.life_events
                        .filter((event) => allowedEvents.includes(event.value))
                        .sort((a, b) => b.count - a.count);
                };

                // Also add debug logging to see what's happening
                const debugCategoryMapping = (category) => {
                    console.log("Selected category:", category);
                    console.log(
                        "Available mappings:",
                        Object.keys(categoryToLifeEvents),
                    );
                    console.log(
                        "Mapped events:",
                        categoryToLifeEvents[category],
                    );
                    console.log(
                        "Facets life events:",
                        facetsData?.life_events?.map((e) => e.value),
                    );
                };

                const iconMap = {
                    "Health and caring": "favorite",
                    "Family and Relationships": "people",
                    "Work and Money": "attach_money",
                    "Housing and Travel": "home",
                    "Disasters and Crime": "warning",
                    "Education and identity": "school",
                    "Having a baby": "child_friendly",
                    "Growing up": "child_care",
                    "Child health": "health_and_safety",
                    "Relationship changes": "favorite_border",
                    "Domestic violence": "report_problem",
                    Work: "work",
                    Ageing: "elderly",
                    Education: "school",
                    "All providers": "public",
                    "Services Australia": "account_balance",
                    "Australian Taxation Office": "receipt",
                    "Department of Health": "local_hospital",
                    "Department of Education": "backpack",
                    "State Government": "location_on",
                    "Non-Government": "business",
                };

                const getIcon = (name) => iconMap[name] || "circle";

                // Profile editor component
                function ProfileView() {
                    const [editMode, setEditMode] = useState(false);
                    const [temp, setTemp] = useState(userProfile);

                    const save = () => {
                        setUserProfile(temp);
                        setEditMode(false);
                    };

                    return (
                        <Paper sx={{ p: 3, mb: 3 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
                                <Avatar sx={{ width: 64, height: 64, bgcolor: '#66d3ee', color: '#0d47a1' }}>
                                    <span className="material-icons">person</span>
                                </Avatar>
                                <Box sx={{ flex: 1 }}>
                                    <Typography variant="h6">{temp.name || 'Guest User'}</Typography>
                                    {profileApiError && (
                                        <Typography variant="body2" color="warning.main">{profileApiError}</Typography>
                                    )}
                                </Box>
                                {!editMode ? (
                                    <Button variant="outlined" onClick={() => setEditMode(true)} startIcon={<span className="material-icons">edit</span>}>Edit</Button>
                                ) : (
                                    <Box sx={{ display: 'flex', gap: 1 }}>
                                        <Button variant="contained" onClick={save}>Save</Button>
                                        <Button variant="text" onClick={() => { setTemp(userProfile); setEditMode(false); }}>Cancel</Button>
                                    </Box>
                                )}
                            </Box>

                            <Grid container spacing={2}>
                                <Grid item xs={12} sm={6} md={3}>
                                    <Typography variant="body2" color="text.secondary">Age</Typography>
                                    {editMode ? (
                                        <TextField size="small" type="number" fullWidth value={temp.age || ''} onChange={(e)=>setTemp({ ...temp, age: e.target.value ? parseInt(e.target.value) : null })} />
                                    ) : (
                                        <Typography>{userProfile.age ?? 'Not set'}</Typography>
                                    )}
                                </Grid>
                                <Grid item xs={12} sm={6} md={3}>
                                    <Typography variant="body2" color="text.secondary">Income</Typography>
                                    {editMode ? (
                                        <TextField size="small" type="number" fullWidth value={temp.income || ''} onChange={(e)=>setTemp({ ...temp, income: e.target.value ? parseInt(e.target.value) : null })} InputProps={{ startAdornment: (<InputAdornment position='start'>$</InputAdornment>) }} />
                                    ) : (
                                        <Typography>{userProfile.income ? `$${userProfile.income.toLocaleString()}` : 'Not set'}</Typography>
                                    )}
                                </Grid>
                                <Grid item xs={12} sm={6} md={3}>
                                    <Typography variant="body2" color="text.secondary">Employment</Typography>
                                    {editMode ? (
                                        <Select size="small" fullWidth value={temp.employment_status || ''} onChange={(e)=>setTemp({ ...temp, employment_status: e.target.value || null })}>
                                            <MenuItem value=''>Not set</MenuItem>
                                            <MenuItem value='employed'>Employed</MenuItem>
                                            <MenuItem value='part_time'>Part-time</MenuItem>
                                            <MenuItem value='casual'>Casual</MenuItem>
                                            <MenuItem value='unemployed'>Unemployed</MenuItem>
                                            <MenuItem value='student'>Student</MenuItem>
                                            <MenuItem value='retired'>Retired</MenuItem>
                                            <MenuItem value='self_employed'>Self-employed</MenuItem>
                                        </Select>
                                    ) : (
                                        <Typography>{userProfile.employment_status || 'Not set'}</Typography>
                                    )}
                                </Grid>
                                <Grid item xs={12} sm={6} md={3}>
                                    <Typography variant="body2" color="text.secondary">Housing</Typography>
                                    {editMode ? (
                                        <Select size="small" fullWidth value={temp.housing_status || ''} onChange={(e)=>setTemp({ ...temp, housing_status: e.target.value || null })}>
                                            <MenuItem value=''>Not set</MenuItem>
                                            <MenuItem value='owner'>Own home</MenuItem>
                                            <MenuItem value='buying'>Mortgage</MenuItem>
                                            <MenuItem value='renting_private'>Renting (private)</MenuItem>
                                            <MenuItem value='renting_public'>Public/social housing</MenuItem>
                                            <MenuItem value='staying_with_others'>Staying with others</MenuItem>
                                            <MenuItem value='homeless'>No fixed address</MenuItem>
                                        </Select>
                                    ) : (
                                        <Typography>{userProfile.housing_status || 'Not set'}</Typography>
                                    )}
                                </Grid>

                                <Grid item xs={12} sm={6} md={3}>
                                    <FormControlLabel control={<Checkbox checked={!!(editMode ? temp.has_children : userProfile.has_children)} onChange={(e)=> editMode ? setTemp({ ...temp, has_children: e.target.checked }) : setUserProfile({ ...userProfile, has_children: e.target.checked }) } />} label="Has children" />
                                </Grid>
                                <Grid item xs={12} sm={6} md={3}>
                                    <FormControlLabel control={<Checkbox checked={!!(editMode ? temp.is_carer : userProfile.is_carer)} onChange={(e)=> editMode ? setTemp({ ...temp, is_carer: e.target.checked }) : setUserProfile({ ...userProfile, is_carer: e.target.checked }) } />} label="Carer" />
                                </Grid>
                                <Grid item xs={12} sm={6} md={3}>
                                    <FormControlLabel control={<Checkbox checked={!!(editMode ? temp.has_disability : userProfile.has_disability)} onChange={(e)=> editMode ? setTemp({ ...temp, has_disability: e.target.checked }) : setUserProfile({ ...userProfile, has_disability: e.target.checked }) } />} label="Disability" />
                                </Grid>
                            </Grid>

                            <Box sx={{ display: 'flex', gap: 1, mt: 3 }}>
                                <Button variant="contained" onClick={() => setMode('journey')} endIcon={<span className='material-icons'>map</span>}>Open Journey</Button>
                                <Button variant="outlined" onClick={() => setMode('guided')} endIcon={<span className='material-icons'>psychology</span>}>Continue Guided</Button>
                                <Button variant="outlined" color="secondary" onClick={() => loadPersonalizedHome(userProfile)} endIcon={<span className='material-icons'>home</span>}>
                                    Personalized Home
                                </Button>
                            </Box>
                        </Paper>
                    );
                }

                // Journey visualization component
                function JourneyView() {
                    const [journeyDisplayMode, setJourneyDisplayMode] = useState('next'); // 'allowed' | 'next' | 'my'
                    const [journeyFull, setJourneyFull] = useState(false);
                    const [nextWeight, setNextWeight] = useState(2.0);
                    const [concurrentWeight, setConcurrentWeight] = useState(1.4);
                    const [selectedDestination, setSelectedDestination] = useState(null);
                    const [showPathfinding, setShowPathfinding] = useState(false);
                    const currentJourneyModeRef = useRef(journeyDisplayMode);

                    // Helpers for colors and utilities
                    const clusterColor = React.useCallback((cluster) => {
                        const map = {
                            'Family': 0x4ade80,
                            'Work': 0x3b82f6,
                            'Health': 0xf87171,
                            'Education': 0xa78bfa,
                            'Housing': 0xfbbf24,
                            'Finance': 0x34d399,
                        };
                        return map[cluster] || 0x9ca3af;
                    }, []);

                    const ensureVizData = React.useCallback(async () => {
                        try {
                            if (!profileId) {
                                await buildServerProfile(userProfile);
                            }
                            const pid = profileId;
                            if (pid) {
                                const resp = await fetch(API_ENDPOINTS.journeyViz(pid));
                                if (resp.ok) {
                                    const data = await resp.json();
                                    setJourneyVizData(data);
                                }
                            }
                        } catch (e) {
                            console.warn('Journey viz load failed:', e.message);
                        }
                    }, [profileId, userProfile]);
                    useEffect(() => { ensureVizData(); }, [ensureVizData]);

                    // Three.js scene init + graph renderer
                    useEffect(() => {
                        let cleanup = () => {};
                        let animationHandle;

                        const initScene = async () => {
                            if (!journeyMapRef.current || !window.d3) return;

                            // D3 SVG setup
                            const containerWidth = journeyMapRef.current.clientWidth;
                            const containerHeight = journeyMapRef.current.clientHeight;
                            
                            // Clear container
                            journeyMapRef.current.innerHTML = '';
                            
                            // Create SVG
                            const svg = d3.select(journeyMapRef.current)
                                .append('svg')
                                .attr('width', containerWidth)
                                .attr('height', containerHeight)
                                .style('background-color', '#f8fafc')
                                .call(d3.zoom()
                                    .scaleExtent([0.1, 4])
                                    .on('zoom', (event) => {
                                        g.attr('transform', event.transform);
                                    }))
                                .on('click', function(event) {
                                    if (event.target === this) {
                                        // Clicked on background - clear selection
                                        setSelectedEvent(null);
                                        clearHighlight();
                                    }
                                });
                            
                            // Create main group for all visualization elements
                            const g = svg.append('g');
                            
                            // Define arrow marker for directed edges
                            svg.append('defs').append('marker')
                                .attr('id', 'arrowhead')
                                .attr('viewBox', '-0 -5 10 10')
                                .attr('refX', 13)
                                .attr('refY', 0)
                                .attr('orient', 'auto')
                                .attr('markerWidth', 6)
                                .attr('markerHeight', 6)
                                .attr('xoverflow', 'visible')
                                .append('svg:path')
                                .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                                .attr('fill', '#666')
                                .style('stroke', 'none');
                            
                            // Create groups for different elements (order matters for layering)
                            const edgesGroup = g.append('g').attr('class', 'edges');
                            const nodesGroup = g.append('g').attr('class', 'nodes');
                            const labelsGroup = g.append('g').attr('class', 'labels');

                            // Internal state for graph objects
                            let graphData = { nodes: [], links: [] };
                            let simulation = null;
                            let currentNodes = null;
                            let currentLinks = null;
                            let currentLabels = null;
                            
                            // Clear highlight function
                            function clearHighlight() {
                                if (!currentNodes || !currentLinks) return;
                                
                                currentNodes
                                    .classed('highlighted', false)
                                    .classed('dimmed', false)
                                    .style('stroke-width', d => d.isCurrent ? 4 : 2);
                                
                                currentLinks
                                    .classed('highlighted', false)
                                    .classed('dimmed', false)
                                    .style('opacity', d => {
                                        switch(d.type) {
                                            case 'next': return 0.9;
                                            case 'concurrent': return 0.7;
                                            default: return 0.4;
                                        }
                                    });
                                
                                if (currentLabels) {
                                    currentLabels.style('opacity', d => d.isImportant || d.isCurrent ? 1 : 0);
                                }
                            }
                            
                            // Highlight selection function
                            function highlightSelection(selectedNode) {
                                if (!selectedNode || !currentNodes || !currentLinks) return;
                                
                                const connectedNodeIds = new Set([selectedNode.id]);
                                
                                // Find connected nodes
                                currentLinks.each(function(d) {
                                    if (d.source.id === selectedNode.id) {
                                        connectedNodeIds.add(d.target.id);
                                    }
                                    if (d.target.id === selectedNode.id) {
                                        connectedNodeIds.add(d.source.id);
                                    }
                                });
                                
                                // Highlight/dim nodes
                                currentNodes
                                    .classed('highlighted', d => d.id === selectedNode.id)
                                    .classed('dimmed', d => !connectedNodeIds.has(d.id))
                                    .style('stroke-width', d => {
                                        if (d.id === selectedNode.id) return 6;
                                        if (connectedNodeIds.has(d.id)) return 4;
                                        return d.isCurrent ? 3 : 1;
                                    });
                                
                                // Highlight/dim links
                                currentLinks
                                    .classed('highlighted', d => 
                                        d.source.id === selectedNode.id || d.target.id === selectedNode.id)
                                    .classed('dimmed', d => 
                                        d.source.id !== selectedNode.id && d.target.id !== selectedNode.id)
                                    .style('opacity', d => {
                                        if (d.source.id === selectedNode.id || d.target.id === selectedNode.id) {
                                            return 1.0;
                                        }
                                        return 0.1;
                                    });
                                
                                // Show labels for selected and connected nodes
                                if (currentLabels) {
                                    currentLabels.style('opacity', d => 
                                        connectedNodeIds.has(d.id) ? 1 : 0);
                                }
                            }

                            // Build graph based on mode
                            function buildGraph(mode, weights = { next: 2.0, concurrent: 1.4 }) {
                                // Clear existing visualization
                                edgesGroup.selectAll('*').remove();
                                nodesGroup.selectAll('*').remove();
                                labelsGroup.selectAll('*').remove();

                                // Choose data source: API → local file → small hardcoded fallback
                                let events = [];
                                if (journeyVizData?.events && journeyVizData.events.length) {
                                    events = journeyVizData.events.slice();
                                } else if (typeof australianLifeEvents !== 'undefined' && Array.isArray(australianLifeEvents) && australianLifeEvents.length) {
                                    events = australianLifeEvents.slice(0, 200);
                                } else {
                                    events = [
                                        { id:'work', event_name:'Work', cluster:'Work', typical_age_range:[18,65], next_states:['changing_careers','buying_home'], frequent_concurrents:['raising_child'], concurrent_disallowed:[] },
                                        { id:'education', event_name:'Education', cluster:'Education', typical_age_range:[5,30], next_states:['work'], frequent_concurrents:['moving_out_of_home'], concurrent_disallowed:[] },
                                        { id:'having_baby', event_name:'Having a baby', cluster:'Family', typical_age_range:[20,45], next_states:['raising_child'], frequent_concurrents:['buying_home'], concurrent_disallowed:[] },
                                        { id:'raising_child', event_name:'Raising a child', cluster:'Family', typical_age_range:[0,18], next_states:[], frequent_concurrents:['work','education'], concurrent_disallowed:[] },
                                        { id:'health', event_name:'Seeking medical help', cluster:'Health', typical_age_range:[0,100], next_states:[], frequent_concurrents:['work'], concurrent_disallowed:[] },
                                        { id:'buying_home', event_name:'Buying a home', cluster:'Housing', typical_age_range:[25,65], next_states:[], frequent_concurrents:['work','raising_child'], concurrent_disallowed:[] },
                                    ];
                                }
                                // Limit node count for performance
                                const maxNodes = mode === 'my' ? 120 : 150;

                                // Map by id for quick lookup
                                const byId = new Map();
                                events.forEach(ev => byId.set(ev.id, ev));

                                // Derive subset for 'my' mode
                                let selectedIds = null;
                                if (mode === 'my') {
                                    const currents = Array.isArray(userProfile?.current_life_events) ? userProfile.current_life_events : [];
                                    const norm = (s) => String(s || '').toLowerCase().replace(/[_-]+/g,' ').trim();
                                    const currentIds = new Set();
                                    const currentsNorm = currents.map(norm);
                                    events.forEach(ev => {
                                        const tokens = [ev.event_name, ev.id, ev.cluster].filter(Boolean).map(norm);
                                        if (tokens.some(t => currentsNorm.some(c => t === c || t.includes(c) || c.includes(t)))) {
                                            currentIds.add(ev.id);
                                        }
                                    });
                                    const nextIds = new Set();
                                    const concurrentIds = new Set();
                                    events.forEach(ev => {
                                        if (currentIds.has(ev.id)) {
                                            (ev.next_states || []).forEach(id => nextIds.add(id));
                                            // Also add a few concurrent options for context
                                            (ev.frequent_concurrents || []).slice(0, 2).forEach(id => concurrentIds.add(id));
                                        }
                                    });
                                    
                                    // Include second-level next steps from the immediate next steps
                                    const secondLevelNextIds = new Set();
                                    events.forEach(ev => {
                                        if (nextIds.has(ev.id)) {
                                            (ev.next_states || []).slice(0, 3).forEach(id => secondLevelNextIds.add(id));
                                        }
                                    });
                                    
                                    selectedIds = new Set([...currentIds, ...nextIds, ...concurrentIds, ...secondLevelNextIds]);
                                    // Fallback: if still empty, include a small cluster by the first current's cluster match
                                    if (selectedIds.size === 0 && currentsNorm.length) {
                                        const c0 = currentsNorm[0];
                                        events.forEach(ev => {
                                            const cMatch = norm(ev.cluster);
                                            if (cMatch && (cMatch === c0 || cMatch.includes(c0) || c0.includes(cMatch))) {
                                                selectedIds.add(ev.id);
                                                (ev.next_states || []).forEach(id => selectedIds.add(id));
                                            }
                                        });
                                    }
                                }

                                const filteredEvents = events.filter(ev => !selectedIds || selectedIds.has(ev.id)).slice(0, maxNodes);
                                if (filteredEvents.length === 0) {
                                    // Ensure we render something
                                    filteredEvents.push(...events.slice(0, Math.min(30, events.length)));
                                }

                                // Build nodes
                                const nodes = filteredEvents.map((ev, i) => ({
                                    id: ev.id,
                                    label: ev.event_name || ev.id,
                                    cluster: ev.cluster,
                                    next: Array.isArray(ev.next_states) ? ev.next_states : [],
                                    concurrents: Array.isArray(ev.frequent_concurrents) ? ev.frequent_concurrents : [],
                                    disallowed: Array.isArray(ev.concurrent_disallowed) ? ev.concurrent_disallowed : [],
                                    typical_age_range: ev.typical_age_range,
                                    // Start at random positions for layout
                                    x: (Math.random() - 0.5) * 600,
                                    z: (Math.random() - 0.5) * 450,
                                    vx: 0,
                                    vz: 0,
                                }));
                                const indexById = new Map(nodes.map((n, idx) => [n.id, idx]));

                                // Edge rules for D3.js - use node IDs instead of indices
                                const edges = [];
                                const addEdge = (sourceIdx, targetIdx, weight, type) => {
                                    if (sourceIdx === undefined || targetIdx === undefined) return;
                                    if (sourceIdx === -1 || targetIdx === -1) return;
                                    if (sourceIdx === targetIdx) return;
                                    
                                    const sourceId = nodes[sourceIdx]?.id;
                                    const targetId = nodes[targetIdx]?.id;
                                    if (!sourceId || !targetId) return;
                                    
                                    // Avoid duplicates
                                    const key = sourceId < targetId ? `${sourceId}-${targetId}` : `${targetId}-${sourceId}`;
                                    if (edges.some(e => e.key === key)) return;
                                    
                                    edges.push({ 
                                        key, 
                                        source: sourceId, 
                                        target: targetId, 
                                        weight, 
                                        type,
                                        sourceIdx, 
                                        targetIdx 
                                    });
                                };

                                // Utility: similarity for pruning in 'allowed'
                                function similarity(a, b) {
                                    let score = 0;
                                    if (a.cluster && b.cluster && a.cluster === b.cluster) score += 1.0;
                                    const ar = a.typical_age_range || [0, 100];
                                    const br = b.typical_age_range || [0, 100];
                                    const overlap = Math.max(0, Math.min(ar[1], br[1]) - Math.max(ar[0], br[0]));
                                    const range = Math.max(ar[1] - ar[0], br[1] - br[0], 1);
                                    score += overlap / range; // 0..1
                                    return score;
                                }

                                if (mode === 'allowed') {
                                    // Connect to a small number of most similar allowed-concurrent nodes to keep it readable
                                    const perNode = 3;
                                    nodes.forEach((n, i) => {
                                        // Candidates that are not disallowed by either side
                                        const candidates = nodes
                                            .map((m, j) => ({ j, m }))
                                            .filter(({ j, m }) => j !== i && !n.disallowed?.includes(m.id) && !m.disallowed?.includes(n.id));
                                        candidates.sort((A, B) => similarity(n, B.m) - similarity(n, A.m));
                                        candidates.slice(0, perNode).forEach(({ j }) => addEdge(i, j, 0.6, 'allowed'));
                                    });
                                } else if (mode === 'next') {
                                    nodes.forEach((n, i) => {
                                        (n.next || []).forEach(id => {
                                            const j = indexById.has(id) ? indexById.get(id) : -1;
                                            addEdge(i, j, weights.next, 'next');
                                        });
                                        (n.concurrents || []).forEach(id => {
                                            const j = indexById.has(id) ? indexById.get(id) : -1;
                                            addEdge(i, j, weights.concurrent, 'concurrent');
                                        });
                                    });
                                } else if (mode === 'my') {
                                    // Show journey paths from current life events to next steps
                                    const currentsById = new Set();
                                    const nextStepIds = new Set();
                                    const currentNames = Array.isArray(userProfile?.current_life_events) ? userProfile.current_life_events : [];
                                    const currentNamesNorm = currentNames.map(s => String(s || '').toLowerCase());
                                    
                                    // Identify current nodes
                                    nodes.forEach((n) => {
                                        const nm = String(n.label || '').toLowerCase();
                                        if (currentNamesNorm.some(c => nm === c || nm.includes(c) || c.includes(nm))) {
                                            currentsById.add(n.id);
                                        }
                                    });
                                    
                                    // Fallback: if no exact label match, try cluster match
                                    if (currentsById.size === 0) {
                                        nodes.forEach((n) => {
                                            const cl = String(n.cluster || '').toLowerCase();
                                            if (cl && currentNamesNorm.some(c => cl === c || cl.includes(c) || c.includes(cl))) {
                                                currentsById.add(n.id);
                                            }
                                        });
                                    }
                                    
                                    // Collect next step IDs
                                    nodes.forEach((n) => {
                                        if (currentsById.has(n.id)) {
                                            (n.next || []).forEach(id => nextStepIds.add(id));
                                        }
                                    });
                                    
                                    // Create edges
                                    nodes.forEach((n, i) => {
                                        if (currentsById.has(n.id)) {
                                            // Strong edges from current to next steps
                                            (n.next || []).forEach(id => {
                                                const j = indexById.has(id) ? indexById.get(id) : -1;
                                                addEdge(i, j, weights.next * 1.2, 'next');
                                            });
                                            // Weaker concurrent edges for context
                                            (n.concurrents || []).slice(0, 2).forEach(id => {
                                                const j = indexById.has(id) ? indexById.get(id) : -1;
                                                addEdge(i, j, weights.concurrent * 0.8, 'concurrent');
                                            });
                                        } else if (nextStepIds.has(n.id)) {
                                            // Show onward paths from next steps
                                            (n.next || []).slice(0, 2).forEach(id => {
                                                const j = indexById.has(id) ? indexById.get(id) : -1;
                                                addEdge(i, j, weights.next * 0.9, 'next');
                                            });
                                        }
                                    });
                                }

                                // Prepare nodes data with enhanced properties
                                nodes.forEach(n => {
                                    n.isCurrent = Array.isArray(userProfile?.current_life_events) && 
                                        userProfile.current_life_events.includes(n.label);
                                    n.isImportant = (n.next?.length > 2) || (n.concurrents?.length > 2);
                                    n.color = clusterColor(n.cluster);
                                    n.radius = n.isImportant ? 12 : 8;
                                    if (n.isCurrent) n.radius += 2;
                                });
                                
                                // Set up D3 force simulation for initial layout
                                simulation = d3.forceSimulation(nodes)
                                    .force('link', d3.forceLink(edges).id(d => d.id).distance(80).strength(0.8))
                                    .force('charge', d3.forceManyBody().strength(-800))
                                    .force('center', d3.forceCenter(containerWidth / 2, containerHeight / 2))
                                    .force('collision', d3.forceCollide().radius(d => d.radius + 5))
                                    .stop();
                                
                                // Run simulation for a few ticks to get initial positions
                                for (let i = 0; i < 100; ++i) simulation.tick();

                                // Create D3 SVG links (edges)
                                const linkColorMap = {
                                    next: '#1976d2',
                                    concurrent: '#f59e0b', 
                                    allowed: '#94a3b8'
                                };
                                
                                const linkWidthMap = {
                                    next: 4,
                                    concurrent: 3,
                                    allowed: 2
                                };
                                
                                currentLinks = edgesGroup
                                    .selectAll('.link')
                                    .data(edges)
                                    .enter()
                                    .append('path')
                                    .attr('class', 'link')
                                    .attr('fill', 'none')
                                    .attr('stroke', d => linkColorMap[d.type] || linkColorMap.allowed)
                                    .attr('stroke-width', d => linkWidthMap[d.type] || linkWidthMap.allowed)
                                    .attr('opacity', d => {
                                        switch(d.type) {
                                            case 'next': return 0.9;
                                            case 'concurrent': return 0.7;
                                            default: return 0.4;
                                        }
                                    })
                                    .attr('d', d => {
                                        const sourceNode = nodes[d.sourceIdx];
                                        const targetNode = nodes[d.targetIdx];
                                        
                                        if (!sourceNode || !targetNode) return '';
                                        
                                        // Create curved path for metro aesthetic
                                        const dx = targetNode.x - sourceNode.x;
                                        const dy = targetNode.y - sourceNode.y;
                                        const dr = Math.sqrt(dx * dx + dy * dy);
                                        const curvature = 0.3; // Adjust curve strength
                                        
                                        return `M${sourceNode.x},${sourceNode.y}A${dr * curvature},${dr * curvature} 0 0,1 ${targetNode.x},${targetNode.y}`;
                                    });
                                
                                // Create D3 SVG nodes
                                currentNodes = nodesGroup
                                    .selectAll('.node')
                                    .data(nodes)
                                    .enter()
                                    .append('circle')
                                    .attr('class', 'node')
                                    .attr('r', d => d.radius)
                                    .attr('cx', d => d.x)
                                    .attr('cy', d => d.y)
                                    .attr('fill', d => d.color)
                                    .attr('stroke', d => d.isCurrent ? '#ff2d55' : '#fff')
                                    .attr('stroke-width', d => d.isCurrent ? 4 : 2)
                                    .style('cursor', 'pointer')
                                    .on('click', function(event, d) {
                                        event.stopPropagation();
                                        setSelectedEvent(d);
                                        highlightSelection(d);
                                    })
                                    .on('mouseover', function(event, d) {
                                        d3.select(this).attr('stroke-width', 3);
                                    })
                                    .on('mouseout', function(event, d) {
                                        d3.select(this).attr('stroke-width', d.isCurrent ? 4 : 2);
                                    });
                                
                                // Create labels
                                currentLabels = labelsGroup
                                    .selectAll('.label')
                                    .data(nodes.filter(d => d.isImportant || d.isCurrent))
                                    .enter()
                                    .append('text')
                                    .attr('class', 'label')
                                    .attr('x', d => d.x)
                                    .attr('y', d => d.y - d.radius - 8)
                                    .attr('text-anchor', 'middle')
                                    .attr('font-family', 'Arial, sans-serif')
                                    .attr('font-size', '12px')
                                    .attr('font-weight', 'bold')
                                    .attr('fill', '#1a1a1a')
                                    .attr('paint-order', 'stroke')
                                    .attr('stroke', '#fff')
                                    .attr('stroke-width', 3)
                                    .attr('stroke-linejoin', 'round')
                                    .style('pointer-events', 'none')
                                    .text(d => {
                                        // Truncate long labels
                                        return d.label.length > 20 ? d.label.substring(0, 17) + '...' : d.label;
                                    });
                                // Save reference for the rebuild function
                                journeyGraphMapRef.current = { indexById, nodes };
                                
                                // Return the data for the visualization
                                return { nodes, edges };
                            }
                            
                            // Set up rebuilder function
                            rebuildGraphRef.current = (mode, weights) => buildGraph(mode || currentJourneyModeRef.current || journeyDisplayMode, weights);
                            
                            // Fit to view function  
                            journeyFitRef.current = () => {
                                const bbox = g.node().getBBox();
                                const width = containerWidth;
                                const height = containerHeight;
                                const midX = bbox.x + bbox.width / 2;
                                const midY = bbox.y + bbox.height / 2;
                                if (bbox.width == 0 || bbox.height == 0) return;
                                const scale = 0.8 / Math.max(bbox.width / width, bbox.height / height);
                                const translate = [width / 2 - scale * midX, height / 2 - scale * midY];
                                
                                svg.transition()
                                    .duration(750)
                                    .call(d3.zoom().transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                            };
                            
                            // Initial build
                            buildGraph(journeyDisplayMode, { next: nextWeight, concurrent: concurrentWeight });
                            
                            // Set up cleanup
                            cleanup = () => {
                                if (simulation) simulation.stop();
                            };
                        };
                        
                        // Initialize the D3 visualization
                        (async () => { await initScene(); })();
                        
                        return () => { if (cleanup) cleanup(); };
                    }, []);

                    
                    // Keep a ref of current display mode
                    useEffect(() => { currentJourneyModeRef.current = journeyDisplayMode; }, [journeyDisplayMode]);

                    
                    // Rebuild the graph when mode changes, but NOT when clicking nodes
                    useEffect(() => {
                        if (typeof rebuildGraphRef.current === 'function') {
                            rebuildGraphRef.current(journeyDisplayMode, { next: nextWeight, concurrent: concurrentWeight });
                        }
                    }, [journeyDisplayMode, nextWeight, concurrentWeight]);
                    
                    // Handle data changes separately - only rebuild if genuinely new data
                    const journeyDataRef = useRef(null);
                    useEffect(() => {
                        if (journeyVizData && journeyVizData !== journeyDataRef.current) {
                            journeyDataRef.current = journeyVizData;
                            if (typeof rebuildGraphRef.current === 'function') {
                                rebuildGraphRef.current(journeyDisplayMode);
                            }
                        }
                    }, [journeyVizData, journeyDisplayMode]);

                    // Resize renderer when toggling fullscreen height
                    useEffect(() => {
                        try { window.dispatchEvent(new Event('resize')); } catch {}
                    }, [journeyFull]);


                    return (
                        <Paper sx={{ p: 0, mb: 3 }}>
                            <Box sx={{ p: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                <Typography variant="h6">Journey Map</Typography>
                                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                                    <ToggleButtonGroup
                                        size="small"
                                        value={journeyDisplayMode}
                                        exclusive
                                        onChange={(e, v) => { if (v) setJourneyDisplayMode(v); }}
                                    >
                                        <ToggleButton value="allowed">All Allowed</ToggleButton>
                                        <ToggleButton value="next">Next & Concurrent</ToggleButton>
                                        <ToggleButton value="my">My Journeys</ToggleButton>
                                    </ToggleButtonGroup>
                                    <Button size="small" onClick={() => { try { journeyFitRef.current && journeyFitRef.current(); } catch {} }}>Reset View</Button>
                                    <Button size="small" onClick={() => setJourneyFull(v => !v)}>{journeyFull ? 'Exit Fullscreen' : 'Fullscreen'}</Button>
                                    <Button size="small" variant="outlined" onClick={() => setMode('profile')}>Edit Profile</Button>
                                </Box>
                            </Box>
                            
                            {/* Weight Controls */}
                            {journeyDisplayMode === 'next' && (
                                <Box sx={{ p: 2, pt: 0, display: 'flex', gap: 3, alignItems: 'center', flexWrap: 'wrap' }}>
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, minWidth: 180 }}>
                                        <Typography variant="caption" sx={{ minWidth: 80 }}>Next Steps:</Typography>
                                        <Slider
                                            size="small"
                                            value={nextWeight}
                                            onChange={(e, v) => setNextWeight(v)}
                                            min={0.5}
                                            max={3.0}
                                            step={0.1}
                                            sx={{ flex: 1 }}
                                        />
                                        <Typography variant="caption" sx={{ minWidth: 30, textAlign: 'right' }}>{nextWeight.toFixed(1)}</Typography>
                                    </Box>
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, minWidth: 180 }}>
                                        <Typography variant="caption" sx={{ minWidth: 80 }}>Concurrent:</Typography>
                                        <Slider
                                            size="small"
                                            value={concurrentWeight}
                                            onChange={(e, v) => setConcurrentWeight(v)}
                                            min={0.2}
                                            max={2.0}
                                            step={0.1}
                                            sx={{ flex: 1 }}
                                        />
                                        <Typography variant="caption" sx={{ minWidth: 30, textAlign: 'right' }}>{concurrentWeight.toFixed(1)}</Typography>
                                    </Box>
                                </Box>
                            )}
                            <Box
                                id="journey-map"
                                ref={journeyMapRef}
                                sx={{ width: '100%', height: journeyFull ? '75vh' : 700, bgcolor: '#eaf4fb', userSelect: 'none' }}
                                onPointerDown={(e)=>{ e.stopPropagation(); }}
                                onPointerUp={(e)=>{ e.stopPropagation(); }}
                                onClick={(e)=>{ e.stopPropagation(); }}
                            />
                            {selectedEvent && (
                                <Paper sx={{ m: 2, p: 2 }} variant="outlined">
                                    <Typography variant="subtitle1" sx={{ fontWeight: 600 }}>{selectedEvent.label || selectedEvent.event_name || selectedEvent.id}</Typography>
                                    <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mt: 1 }}>
                                        {selectedEvent.cluster && (
                                            <Chip label={`Cluster: ${selectedEvent.cluster}`} color="primary" size="small" />
                                        )}
                                        {Array.isArray(selectedEvent.typical_age_range) && (
                                            <Chip label={`Age: ${selectedEvent.typical_age_range[0]}–${selectedEvent.typical_age_range[1]}`} size="small" />
                                        )}
                                        {selectedEvent.eligibility_status && (
                                            <Chip label={`Eligibility: ${selectedEvent.eligibility_status}`} size="small" />
                                        )}
                                    </Box>
                                    <Grid container spacing={2} sx={{ mt: 1 }}>
                                        <Grid item xs={12} md={4}>
                                            <Typography variant="body2" sx={{ fontWeight: 600 }}>Next states</Typography>
                                            <List dense>
                                                {(selectedEvent.next || selectedEvent.next_states || []).slice(0, 20).map((id, i) => (
                                                    <ListItem key={i} disableGutters>
                                                        <ListItemText primary={id} />
                                                    </ListItem>
                                                ))}
                                                {(!selectedEvent.next && !selectedEvent.next_states) && (
                                                    <ListItem disableGutters><ListItemText primary="None" /></ListItem>
                                                )}
                                            </List>
                                        </Grid>
                                        <Grid item xs={12} md={4}>
                                            <Typography variant="body2" sx={{ fontWeight: 600 }}>Frequent concurrents</Typography>
                                            <List dense>
                                                {(selectedEvent.concurrents || selectedEvent.frequent_concurrents || []).slice(0, 20).map((id, i) => (
                                                    <ListItem key={i} disableGutters>
                                                        <ListItemText primary={id} />
                                                    </ListItem>
                                                ))}
                                                {(!selectedEvent.concurrents && !selectedEvent.frequent_concurrents) && (
                                                    <ListItem disableGutters><ListItemText primary="None" /></ListItem>
                                                )}
                                            </List>
                                        </Grid>
                                        <Grid item xs={12} md={4}>
                                            <Typography variant="body2" sx={{ fontWeight: 600 }}>Concurrent disallowed</Typography>
                                            <List dense>
                                                {(selectedEvent.disallowed || selectedEvent.concurrent_disallowed || []).slice(0, 20).map((id, i) => (
                                                    <ListItem key={i} disableGutters>
                                                        <ListItemText primary={id} />
                                                    </ListItem>
                                                ))}
                                                {(!selectedEvent.disallowed && !selectedEvent.concurrent_disallowed) && (
                                                    <ListItem disableGutters><ListItemText primary="None" /></ListItem>
                                                )}
                                            </List>
                                        </Grid>
                                    </Grid>
                                    
                                    {/* Destination Selection */}
                                    <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid #ddd' }}>
                                        <Typography variant="body2" sx={{ fontWeight: 600, mb: 1 }}>Journey Planning</Typography>
                                        <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
                                            <Button
                                                size="small"
                                                variant={selectedDestination?.id === selectedEvent.id ? "contained" : "outlined"}
                                                onClick={() => setSelectedDestination(selectedEvent)}
                                            >
                                                Set as Destination
                                            </Button>
                                            {selectedDestination && selectedDestination.id !== selectedEvent.id && (
                                                <Button
                                                    size="small"
                                                    variant="contained"
                                                    color="secondary"
                                                    onClick={() => setShowPathfinding(true)}
                                                >
                                                    Plan Journey to {selectedDestination.label}
                                                </Button>
                                            )}
                                            {selectedDestination && (
                                                <Chip 
                                                    label={`Destination: ${selectedDestination.label}`} 
                                                    color="secondary" 
                                                    size="small" 
                                                    onDelete={() => setSelectedDestination(null)}
                                                />
                                            )}
                                        </Box>
                                        {selectedDestination && showPathfinding && (
                                            <Box sx={{ mt: 2, p: 1, bgcolor: '#f5f5f5', borderRadius: 1 }}>
                                                <Typography variant="caption" color="text.secondary">
                                                    Journey planning will help you identify the steps needed to reach "{selectedDestination.label}" from your current situation.
                                                </Typography>
                                                <Box sx={{ mt: 1 }}>
                                                    <Button size="small" onClick={() => setShowPathfinding(false)}>Close</Button>
                                                </Box>
                                            </Box>
                                        )}
                                    </Box>
                                </Paper>
                            )}
                        </Paper>
                    );
                }

                return (
                    <>
                        <AppBar
                            position="sticky"
                            sx={{ bgcolor: "#66d3ee", color: "#333" }}
                        >
                            <Toolbar>
                                <Box
                                    className="logo-container"
                                    sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', gap: 1 }}
                                >
                                    <span className="material-icons" style={{ fontSize: '2rem', color: '#1976d2' }}>account_balance</span>
                                    <Typography variant="h6" component="div" sx={{ fontWeight: 700 }}>
                                        myGov
                                    </Typography>
                                </Box>

                                <Tabs
                                    value={mode}
                                    onChange={(e, newMode) => setMode(newMode)}
                                    sx={{
                                        "& .MuiTab-root": { color: "#333" },
                                        "& .Mui-selected": { color: "#1976d2" },
                                    }}
                                >
                                    <Tab label="Profile" value="profile" icon={<span className="material-icons">person</span>} iconPosition="end" />
                                    <Tab 
                                        label="Guided" 
                                        value="guided"
                                        icon={
                                            <span className="material-icons">
                                                psychology
                                            </span>
                                        }
                                        iconPosition="end"
                                    />
                                    <Tab label="Home" value="home" />
                                    <Tab label="Browse" value="browse" />
                                    <Tab
                                        label="Search"
                                        value="search"
                                        icon={
                                            <span className="material-icons">
                                                search
                                            </span>
                                        }
                                        iconPosition="end"
                                    />
                                    <Tab
                                        label="Chat"
                                        value="chat"
                                        icon={
                                            <span className="material-icons">
                                                chat
                                            </span>
                                        }
                                        iconPosition="end"
                                    />
                                    <Tab label="Journey" value="journey" icon={<span className="material-icons">map</span>} iconPosition="end" />
                                </Tabs>

                                <Button
                                    color="inherit"
                                    startIcon={
                                        <span className="material-icons">
                                            login
                                        </span>
                                    }
                                >
                                    Sign in
                                </Button>
                            </Toolbar>
                        </AppBar>

                        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
                            {error && (
                                <Alert
                                    severity="error"
                                    sx={{ mb: 2 }}
                                    onClose={() => setError(null)}
                                >
                                    {error}
                                </Alert>
                            )}

                            {/* Navigation Questions (shown in browse, home, and search modes) */}
                            {(mode === "browse" ||
                                mode === "home" ||
                                mode === "search") && (
                                <Paper sx={{ p: 3, mb: 3 }}>
                                    <Grid container spacing={3}>
                                        <Grid
                                            item
                                            xs={12}
                                            md={mode === "search" ? 4 : 12}
                                        >
                                            <FormControl component="fieldset">
                                                <FormLabel component="legend">
                                                    What area do you need help
                                                    with?
                                                </FormLabel>
                                                <RadioGroup
                                                    row={mode !== "search"}
                                                    value={
                                                        mode === "search"
                                                            ? searchFilters.category
                                                            : selections.category
                                                    }
                                                    onChange={(e) => {
                                                        if (mode === "search") {
                                                            setSearchFilters({
                                                                ...searchFilters,
                                                                category:
                                                                    e.target
                                                                        .value,
                                                                lifeEvent: null,
                                                                provider: null,
                                                            });
                                                        } else {
                                                            // RESET LIFE EVENT WHEN CATEGORY CHANGES
                                                            setSelections({
                                                                ...selections,
                                                                category:
                                                                    e.target
                                                                        .value,
                                                                lifeEvent: null,
                                                                provider: null,
                                                            });
                                                        }
                                                        // DEBUG: Log category selection
                                                        debugCategoryMapping(
                                                            e.target.value,
                                                        );
                                                    }}
                                                >
                                                    {facetsData?.categories?.map(
                                                        (cat) => (
                                                            <FormControlLabel
                                                                key={cat.value}
                                                                value={
                                                                    cat.value
                                                                }
                                                                control={
                                                                    <Radio />
                                                                }
                                                                label={
                                                                    <Box
                                                                        sx={{
                                                                            display:
                                                                                "flex",
                                                                            alignItems:
                                                                                "center",
                                                                            gap: 1,
                                                                        }}
                                                                    >
                                                                        <span className="material-icons">
                                                                            {getIcon(
                                                                                cat.value,
                                                                            )}
                                                                        </span>
                                                                        {
                                                                            cat.value
                                                                        }
                                                                    </Box>
                                                                }
                                                            />
                                                        ),
                                                    )}
                                                </RadioGroup>
                                            </FormControl>
                                        </Grid>

                                        {/* MODIFY LIFE EVENT SECTION TO USE FILTERED OPTIONS FOR ALL MODES */}
                                        {(mode === "search"
                                            ? searchFilters.category
                                            : selections.category) && (
                                            <Grid
                                                item
                                                xs={12}
                                                md={mode === "search" ? 4 : 12}
                                            >
                                                <FormControl component="fieldset">
                                                    <FormLabel component="legend">
                                                        What life event or
                                                        situation applies?
                                                    </FormLabel>
                                                    <RadioGroup
                                                        row={mode !== "search"}
                                                        value={
                                                            mode === "search"
                                                                ? searchFilters.lifeEvent
                                                                : selections.lifeEvent
                                                        }
                                                        onChange={(e) => {
                                                            if (
                                                                mode ===
                                                                "search"
                                                            ) {
                                                                setSearchFilters(
                                                                    {
                                                                        ...searchFilters,
                                                                        lifeEvent:
                                                                            e
                                                                                .target
                                                                                .value,
                                                                    },
                                                                );
                                                            } else {
                                                                // RESET PROVIDER WHEN LIFE EVENT CHANGES
                                                                setSelections({
                                                                    ...selections,
                                                                    lifeEvent:
                                                                        e.target
                                                                            .value,
                                                                    provider:
                                                                        null,
                                                                });
                                                            }
                                                        }}
                                                    >
                                                        {/* USE FILTERED LIFE EVENTS FOR ALL MODES */}
                                                        {getFilteredLifeEvents()?.map(
                                                            (event) => (
                                                                <FormControlLabel
                                                                    key={
                                                                        event.value
                                                                    }
                                                                    value={
                                                                        event.value
                                                                    }
                                                                    control={
                                                                        <Radio />
                                                                    }
                                                                    label={
                                                                        <Box
                                                                            sx={{
                                                                                display:
                                                                                    "flex",
                                                                                alignItems:
                                                                                    "center",
                                                                                gap: 1,
                                                                            }}
                                                                        >
                                                                            <span className="material-icons">
                                                                                {getIcon(
                                                                                    event.value,
                                                                                )}
                                                                            </span>
                                                                            {
                                                                                event.value
                                                                            }
                                                                        </Box>
                                                                    }
                                                                />
                                                            ),
                                                        )}
                                                    </RadioGroup>
                                                </FormControl>
                                            </Grid>
                                        )}

                                        {(mode === "search"
                                            ? searchFilters.lifeEvent
                                            : selections.lifeEvent) && (
                                            <Grid
                                                item
                                                xs={12}
                                                md={mode === "search" ? 4 : 12}
                                            >
                                                <FormControl component="fieldset">
                                                    <FormLabel component="legend">
                                                        Which service provider?
                                                    </FormLabel>
                                                    <RadioGroup
                                                        row={mode !== "search"}
                                                        value={
                                                            mode === "search"
                                                                ? searchFilters.provider
                                                                : selections.provider
                                                        }
                                                        onChange={(e) => {
                                                            if (
                                                                mode ===
                                                                "search"
                                                            ) {
                                                                setSearchFilters(
                                                                    {
                                                                        ...searchFilters,
                                                                        provider:
                                                                            e
                                                                                .target
                                                                                .value,
                                                                    },
                                                                );
                                                            } else {
                                                                setSelections({
                                                                    ...selections,
                                                                    provider:
                                                                        e.target
                                                                            .value,
                                                                });
                                                            }
                                                        }}
                                                    >
                                                        <FormControlLabel
                                                            value="All providers"
                                                            control={<Radio />}
                                                            label={
                                                                <Box
                                                                    sx={{
                                                                        display:
                                                                            "flex",
                                                                        alignItems:
                                                                            "center",
                                                                        gap: 1,
                                                                    }}
                                                                >
                                                                    <span className="material-icons">
                                                                        {getIcon(
                                                                            "All providers",
                                                                        )}
                                                                    </span>
                                                                    All
                                                                    providers
                                                                </Box>
                                                            }
                                                        />
                                                        {facetsData?.provider?.map(
                                                            (provider) => (
                                                                <FormControlLabel
                                                                    key={
                                                                        provider.value
                                                                    }
                                                                    value={
                                                                        provider.value
                                                                    }
                                                                    control={
                                                                        <Radio />
                                                                    }
                                                                    label={
                                                                        <Box
                                                                            sx={{
                                                                                display:
                                                                                    "flex",
                                                                                alignItems:
                                                                                    "center",
                                                                                gap: 1,
                                                                            }}
                                                                        >
                                                                            <span className="material-icons">
                                                                                {getIcon(
                                                                                    provider.value,
                                                                                )}
                                                                            </span>
                                                                            {
                                                                                provider.value
                                                                            }
                                                                        </Box>
                                                                    }
                                                                />
                                                            ),
                                                        )}
                                                    </RadioGroup>
                                                </FormControl>
                                            </Grid>
                                        )}
                                    </Grid>
                                </Paper>
                            )}

                            {/* Search Mode */}
                            {mode === "search" && (
                                <Paper sx={{ p: 3, mb: 3 }}>
                                    <TextField
                                        fullWidth
                                        variant="outlined"
                                        placeholder="Search for government services..."
                                        value={searchQuery}
                                        onChange={(e) =>
                                            setSearchQuery(e.target.value)
                                        }
                                        onKeyPress={(e) =>
                                            e.key === "Enter" && handleSearch()
                                        }
                                        InputProps={{
                                            endAdornment: (
                                                <InputAdornment position="end">
                                                    <IconButton
                                                        onClick={handleSearch}
                                                    >
                                                        <span className="material-icons">
                                                            search
                                                        </span>
                                                    </IconButton>
                                                </InputAdornment>
                                            ),
                                        }}
                                    />

                                    {/* Active filters */}
                                    <Box
                                        className="filter-chips"
                                        sx={{ mt: 2 }}
                                    >
                                        {Object.entries(searchFilters).map(
                                            ([key, value]) =>
                                                value && (
                                                    <Chip
                                                        key={key}
                                                        label={value}
                                                        onDelete={() =>
                                                            setSearchFilters({
                                                                ...searchFilters,
                                                                [key]: null,
                                                            })
                                                        }
                                                    />
                                                ),
                                        )}
                                    </Box>
                                </Paper>
                            )}

                            {/* Profile Mode */}
                            {mode === "profile" && (
                                <ProfileView />
                            )}

                            {/* Guided Mode - Chat-based Profile Builder */}
                            {mode === "guided" && (
                                <Box sx={{ display: 'flex', height: '70vh', bgcolor: '#f9f9f9', borderRadius: 2, overflow: 'hidden' }}>
                                    {/* Chat Area */}
                                    <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                                        {/* Chat Messages */}
                                        <Box 
                                            sx={{ 
                                                flex: 1, 
                                                overflow: 'auto', 
                                                p: 2,
                                                display: 'flex',
                                                flexDirection: 'column',
                                                gap: 2
                                            }}
                                        >
                                            {guidedChatMessages.map((msg) => (
                                                <Box 
                                                    key={msg.id}
                                                    sx={{ 
                                                        display: 'flex',
                                                        justifyContent: msg.type === 'user' ? 'flex-end' : 'flex-start',
                                                        mb: 1
                                                    }}
                                                >
                                                    <Paper 
                                                        sx={{ 
                                                            p: 2, 
                                                            maxWidth: '70%',
                                                            bgcolor: msg.type === 'user' ? 'primary.main' : 'white',
                                                            color: msg.type === 'user' ? 'white' : 'text.primary',
                                                            borderRadius: 2
                                                        }}
                                                    >
                                                        <Typography variant="body1">
                                                            {msg.text}
                                                        </Typography>
                                                    </Paper>
                                                </Box>
                                            ))}
                                            
                                            {loadingServices && (
                                                <Box sx={{ display: 'flex', justifyContent: 'flex-start', mb: 1 }}>
                                                    <Paper sx={{ p: 2, bgcolor: 'white', borderRadius: 2 }}>
                                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                                            <CircularProgress size={20} />
                                                            <Typography variant="body1">
                                                                Finding services for you...
                                                            </Typography>
                                                        </Box>
                                                    </Paper>
                                                </Box>
                                            )}
                                        </Box>

                                        {/* Chat Input Area */}
                                        {!isProfileComplete && (
                                            <Box sx={{ p: 2, borderTop: '1px solid #eee', bgcolor: 'white' }}>
                                                {profileQuestions[currentQuestion]?.type === 'choice' && (
                                                    <Box sx={{ mb: 2 }}>
                                                        <Grid container spacing={1}>
                                                            {profileQuestions[currentQuestion].options.map((option) => (
                                                                <Grid item xs={12} sm={6} key={option.value}>
                                                                    <Button
                                                                        fullWidth
                                                                        variant="outlined"
                                                                        onClick={() => handleChatResponse(option.value)}
                                                                        sx={{ 
                                                                            justifyContent: 'flex-start',
                                                                            textAlign: 'left',
                                                                            py: 1
                                                                        }}
                                                                    >
                                                                        {option.label}
                                                                    </Button>
                                                                </Grid>
                                                            ))}
                                                        </Grid>
                                                    </Box>
                                                )}

                                                {profileQuestions[currentQuestion]?.type === 'boolean' && (
                                                    <Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
                                                        <Button
                                                            variant="contained"
                                                            onClick={() => handleChatResponse('true')}
                                                        >
                                                            Yes
                                                        </Button>
                                                        <Button
                                                            variant="outlined"
                                                            onClick={() => handleChatResponse('false')}
                                                        >
                                                            No
                                                        </Button>
                                                    </Box>
                                                )}

                                                {profileQuestions[currentQuestion]?.type === 'multiple_choice' && (
                                                    <Box sx={{ mb: 2 }}>
                                                        <Grid container spacing={1}>
                                                            {profileQuestions[currentQuestion].options.map((option) => (
                                                                <Grid item xs={12} sm={6} key={option.value}>
                                                                    <Button
                                                                        fullWidth
                                                                        variant="outlined"
                                                                        onClick={() => {
                                                                            if (option.value === 'none') {
                                                                                handleChatResponse([]);
                                                                            } else {
                                                                                handleChatResponse([option.value]);
                                                                            }
                                                                        }}
                                                                        sx={{ 
                                                                            justifyContent: 'flex-start',
                                                                            textAlign: 'left',
                                                                            py: 1
                                                                        }}
                                                                    >
                                                                        {option.label}
                                                                    </Button>
                                                                </Grid>
                                                            ))}
                                                        </Grid>
                                                    </Box>
                                                )}

                                                {profileQuestions[currentQuestion]?.type === 'number' && (
                                                    <Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
                                                        <TextField
                                                            fullWidth
                                                            type="number"
                                                            value={guidedChatInput}
                                                            onChange={(e) => setGuidedChatInput(e.target.value)}
                                                            onKeyPress={(e) => {
                                                                if (e.key === 'Enter' && guidedChatInput.trim()) {
                                                                    handleChatResponse(guidedChatInput.trim());
                                                                    setGuidedChatInput('');
                                                                }
                                                            }}
                                                            placeholder="Enter your answer..."
                                                            InputProps={{
                                                                startAdornment: profileQuestions[currentQuestion].prefix && (
                                                                    <InputAdornment position="start">
                                                                        {profileQuestions[currentQuestion].prefix}
                                                                    </InputAdornment>
                                                                ),
                                                            }}
                                                        />
                                                        <Button
                                                            variant="contained"
                                                            onClick={() => {
                                                                if (guidedChatInput.trim()) {
                                                                    handleChatResponse(guidedChatInput.trim());
                                                                    setGuidedChatInput('');
                                                                }
                                                            }}
                                                            disabled={!guidedChatInput.trim()}
                                                        >
                                                            Send
                                                        </Button>
                                                        {profileQuestions[currentQuestion].optional && (
                                                            <Button
                                                                variant="outlined"
                                                                onClick={() => {
                                                                    handleChatResponse('');
                                                                    setGuidedChatInput('');
                                                                }}
                                                            >
                                                                Skip
                                                            </Button>
                                                        )}
                                                    </Box>
                                                )}
                                            </Box>
                                        )}
                                    </Box>

                                    {/* Results Panel */}
                                    {isProfileComplete && matchedServices.length > 0 && (
                                        <Box sx={{ width: '50%', borderLeft: '1px solid #eee', bgcolor: 'white' }}>
                                            <Box sx={{ p: 2, borderBottom: '1px solid #eee' }}>
                                                <Typography variant="h6" gutterBottom>
                                                    Your Personalized Services
                                                </Typography>
                                                <Typography variant="body2" color="text.secondary">
                                                    Based on your profile, here are the services most relevant to you:
                                                </Typography>
                                            </Box>
                                            
                                            <Box sx={{ overflow: 'auto', height: 'calc(70vh - 80px)', p: 2 }}>
                                                <Stack spacing={2}>
                                                    {matchedServices.map((service) => (
                                                        <Card key={service.id} sx={{ border: '1px solid #eee' }}>
                                                            <CardContent sx={{ pb: 1 }}>
                                                                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                                                                    <Typography variant="h6" sx={{ fontSize: '1rem' }}>
                                                                        {service.title || 'Government Service'}
                                                                    </Typography>
                                                                    <Chip 
                                                                        label={`${Math.round(service.eligibility_score * 100)}% Match`}
                                                                        color={service.eligibility_score > 0.8 ? 'success' : service.eligibility_score > 0.6 ? 'warning' : 'default'}
                                                                        size="small"
                                                                    />
                                                                </Box>
                                                                
                                                                <Typography variant="body2" color="text.secondary" gutterBottom>
                                                                    {service.provider || 'Services Australia'}
                                                                </Typography>
                                                                
                                                                <Typography variant="body2" paragraph>
                                                                    {service.description ? 
                                                                        (service.description.length > 150 ? 
                                                                            service.description.substring(0, 150) + '...' : 
                                                                            service.description) :
                                                                        'This service may be relevant to your current situation. Click "Learn More" for full details.'
                                                                    }
                                                                </Typography>
                                                                
                                                                <Typography variant="caption" color="primary" gutterBottom sx={{ display: 'block' }}>
                                                                    Why this matches: {service.match_reason}
                                                                </Typography>
                                                                
                                                                {service.url ? (
                                                                    <Button 
                                                                        size="small" 
                                                                        variant="contained"
                                                                        href={service.url}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        sx={{ mt: 1 }}
                                                                    >
                                                                        Learn More
                                                                    </Button>
                                                                ) : (
                                                                    <Button 
                                                                        size="small" 
                                                                        variant="outlined"
                                                                        disabled
                                                                        sx={{ mt: 1 }}
                                                                    >
                                                                        Details Not Available
                                                                    </Button>
                                                                )}
                                                            </CardContent>
                                                        </Card>
                                                    ))}
                                                </Stack>
                                            </Box>
                                        </Box>
                                    )}
                                </Box>
                            )}

                            {/* Chat Mode */}
                            {mode === "chat" && (
                                <Paper sx={{ p: 3 }}>
                                    <Typography variant="h5" gutterBottom>
                                        AI Assistant
                                    </Typography>
                                    
                                    {/* Provider Status Warning - only show if Bedrock unavailable */}
                                    {modelStatus && !modelStatus.bedrock?.available && (
                                        <Alert severity="warning" sx={{ mb: 2 }}>
                                            <Typography variant="body2">
                                                <strong>AI service unavailable.</strong> Please check Bedrock configuration.
                                            </Typography>
                                        </Alert>
                                    )}
                                    <Box className="chat-messages">
                                        {chatMessages.map((msg, index) => (
                                            <Fade in key={msg.id || index}>
                                                <Box
                                                    className={`chat-message ${msg.type}`}
                                                >
                                                    <Avatar className="chat-avatar">
                                                        {msg.type === "user"
                                                            ? "U"
                                                            : msg.type === "system"
                                                            ? "🔍"  
                                                            : "AI"}
                                                    </Avatar>
                                                    <Paper
                                                        className="chat-bubble"
                                                        elevation={1}
                                                    >
                                                        <Typography variant="body2">
                                                            {msg.loading && (
                                                                <Box
                                                                    sx={{
                                                                        display:
                                                                            "flex",
                                                                        alignItems:
                                                                            "center",
                                                                        gap: 1,
                                                                    }}
                                                                >
                                                                    <CircularProgress
                                                                        size={
                                                                            16
                                                                        }
                                                                    />
                                                                    <span dangerouslySetInnerHTML={{ __html: parseMarkdown(msg.text) }} />
                                                                </Box>
                                                            )}
                                                            {!msg.loading && (
                                                                <span dangerouslySetInnerHTML={{ __html: parseMarkdown(msg.text) }} />
                                                            )}
                                                        </Typography>
                                                        {msg.error && (
                                                            <Typography
                                                                variant="caption"
                                                                color="error"
                                                                sx={{
                                                                    mt: 1,
                                                                    display:
                                                                        "block",
                                                                }}
                                                            >
                                                                Try selecting a different model from the dropdown.
                                                            </Typography>
                                                        )}
                                                        {msg.sources && (
                                                            <Box sx={{ mt: 1 }}>
                                                                <Typography variant="caption" color="text.secondary">
                                                                    Sources:
                                                                </Typography>
                                                                {msg.sources.map((source, idx) => (
                                                                    <Typography key={idx} variant="caption" sx={{ display: 'block', ml: 1 }}>
                                                                        • {source.title} ({source.provider})
                                                                    </Typography>
                                                                ))}
                                                            </Box>
                                                        )}
                                                    </Paper>
                                                </Box>
                                            </Fade>
                                        ))}
                                    </Box>
                                    <Box sx={{ display: "flex", gap: 1, alignItems: "center", flexWrap: 'wrap' }}>
                                        <FormControl size="small" sx={{ minWidth: 320 }}>
                                            <InputLabel id="model-select-label">Model</InputLabel>
                                            <Select
                                                labelId="model-select-label"
                                                label="Model"
                                                value={llmModel}
                                                onChange={(e) => setLlmModel(e.target.value)}
                                            >
                                                {availableModels.map((m) => (
                                                    <MenuItem 
                                                        key={m.value} 
                                                        value={m.value}
                                                        disabled={m.status === 'error'}
                                                    >
                                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, width: '100%' }}>
                                                            <span>{m.label}</span>
                                                            {m.status === 'available' && (
                                                                <span 
                                                                    className="material-icons" 
                                                                    style={{ fontSize: 16, color: '#4caf50' }}
                                                                >
                                                                    check_circle
                                                                </span>
                                                            )}
                                                            {m.status === 'unavailable' && (
                                                                <span 
                                                                    className="material-icons" 
                                                                    style={{ fontSize: 16, color: '#ff9800' }}
                                                                >
                                                                    warning
                                                                </span>
                                                            )}
                                                            {m.status === 'error' && (
                                                                <span 
                                                                    className="material-icons" 
                                                                    style={{ fontSize: 16, color: '#f44336' }}
                                                                >
                                                                    error
                                                                </span>
                                                            )}
                                                        </Box>
                                                    </MenuItem>
                                                ))}
                                            </Select>
                                        </FormControl>
                                        {/* Refresh models button */}
                                        <IconButton 
                                            onClick={loadModels}
                                            disabled={loadingModels}
                                            size="small"
                                            title="Refresh available models"
                                        >
                                            {loadingModels ? (
                                                <CircularProgress size={16} />
                                            ) : (
                                                <span className="material-icons">refresh</span>
                                            )}
                                        </IconButton>

                                        {/* Provider status indicators */}
                                        {modelStatus && (
                                            <Box sx={{ display: 'flex', gap: 0.5 }}>
                                                {modelStatus.bedrock?.available && (
                                                    <Chip
                                                        size="small"
                                                        label="Bedrock"
                                                        color="success"
                                                        variant="outlined"
                                                        icon={<span className="material-icons" style={{fontSize: 14}}>cloud</span>}
                                                    />
                                                )}
                                            </Box>
                                        )}
                                        <TextField
                                            fullWidth
                                            variant="outlined"
                                            placeholder="Ask me anything about government services..."
                                            value={chatInput}
                                            onChange={(e) =>
                                                setChatInput(e.target.value)
                                            }
                                            onKeyPress={(e) =>
                                                e.key === "Enter" &&
                                                handleChatSend()
                                            }
                                        />
                                        <FormControlLabel 
                                            control={<Checkbox size="small" checked={useProfileForChat} onChange={(e)=> setUseProfileForChat(e.target.checked)} />}
                                            label={<Typography variant="caption">Use my local profile</Typography>}
                                            sx={{ ml: 1 }}
                                        />
                                        <Button
                                            variant="contained"
                                            onClick={handleChatSend}
                                            endIcon={
                                                <span className="material-icons">
                                                    send
                                                </span>
                                            }
                                        >
                                            Send
                                        </Button>
                                    </Box>
                                </Paper>
                            )}

                            {/* Journey Mode */}
                            {mode === "journey" && (
                                <JourneyView />
                            )}

                            {/* Results Display */}
                            {loading && (
                                <Box
                                    sx={{
                                        display: "flex",
                                        justifyContent: "center",
                                        my: 4,
                                    }}
                                >
                                    <CircularProgress />
                                </Box>
                            )}

                            {!loading && results.length > 0 && (
                                <>
                                    {/* Home Mode - Static Content */}
                                    {mode === "home" && (
                                        <Box
                                            sx={{
                                                maxWidth: "800px",
                                                mx: "auto",
                                                "& .fragment-content": {
                                                    mb: 3,
                                                    "& h1, & h2, & h3, & h4, & h5, & h6":
                                                        {
                                                            mt: 2,
                                                            mb: 1,
                                                            fontWeight:
                                                                "normal",
                                                        },
                                                    "& p": {
                                                        mb: 1.5,
                                                        lineHeight: 1.6,
                                                    },
                                                    "& ul, & ol": {
                                                        mb: 1.5,
                                                        pl: 3,
                                                    },
                                                    "& li": { mb: 0.5 },
                                                    "& .info-box, & .alert": {
                                                        p: 2,
                                                        mb: 2,
                                                        borderRadius: 1,
                                                        backgroundColor:
                                                            "#f5f5f5",
                                                        border: "1px solid #e0e0e0",
                                                    },
                                                    "& .alert": {
                                                        backgroundColor:
                                                            "#fff3cd",
                                                        borderColor: "#ffeeba",
                                                        color: "#856404",
                                                    },
                                                    "& table": {
                                                        width: "100%",
                                                        mb: 2,
                                                        borderCollapse:
                                                            "collapse",
                                                        "& th, & td": {
                                                            border: "1px solid #ddd",
                                                            p: 1,
                                                            textAlign: "left",
                                                        },
                                                        "& th": {
                                                            backgroundColor:
                                                                "#f5f5f5",
                                                            fontWeight: "bold",
                                                        },
                                                    },
                                                    "& form": {
                                                        mb: 2,
                                                        p: 2,
                                                        border: "1px solid #ddd",
                                                        borderRadius: 1,
                                                    },
                                                },
                                            }}
                                        >
                                            {/* Page Title (H1) */}
                                            <Typography
                                                variant="h3"
                                                component="h1"
                                                gutterBottom
                                                sx={{ fontWeight: 400, mb: 3 }}
                                            >
                                                {selections.lifeEvent} -{" "}
                                                {selections.category}
                                            </Typography>

                                            <Typography
                                                variant="body1"
                                                sx={{
                                                    mb: 4,
                                                    color: "text.secondary",
                                                }}
                                            >
                                                Information and services for{" "}
                                                {selections.lifeEvent?.toLowerCase()}{" "}
                                                from{" "}
                                                {selections.provider ===
                                                "All providers"
                                                    ? "all government providers"
                                                    : selections.provider}
                                                .
                                            </Typography>

                                            {/* AI Reordering Status */}
                                            {loadingReorder && results.length > 0 && (
                                                <Paper 
                                                    sx={{ 
                                                        p: 2, 
                                                        mb: 3, 
                                                        backgroundColor: '#f8f9fa',
                                                        border: '1px solid #e9ecef'
                                                    }}
                                                >
                                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                                        <CircularProgress size={16} />
                                                        <Typography variant="body2" color="text.secondary">
                                                            Optimizing content flow for better reading experience...
                                                        </Typography>
                                                    </Box>
                                                </Paper>
                                            )}

                                            {/* Group results hierarchically */}
                                            {(() => {
                                                // Use reordered results if available, otherwise use original results
                                                const resultsToDisplay = reorderedResults || results;
                                                
                                                // Group by category -> life event -> page title
                                                const grouped = resultsToDisplay.reduce(
                                                    (acc, item) => {
                                                        const cat =
                                                            item.category ||
                                                            "General Information";
                                                        const event =
                                                            item.lifeEvent ||
                                                            "General";
                                                        const page =
                                                            item.hierarchy ||
                                                            "Information";

                                                        if (!acc[cat])
                                                            acc[cat] = {};
                                                        if (!acc[cat][event])
                                                            acc[cat][event] =
                                                                {};
                                                        if (
                                                            !acc[cat][event][
                                                                page
                                                            ]
                                                        )
                                                            acc[cat][event][
                                                                page
                                                            ] = [];

                                                        acc[cat][event][
                                                            page
                                                        ].push(item);
                                                        return acc;
                                                    },
                                                    {},
                                                );

                                                return Object.entries(
                                                    grouped,
                                                ).map(
                                                    ([
                                                        category,
                                                        eventGroups,
                                                    ]) => {
                                                        const categoryId = `category-${category.replace(/\s+/g, '-')}`;
                                                        return (
                                                            <Accordion
                                                                key={category}
                                                                expanded={expandedAccordions.has(categoryId)}
                                                                onChange={() => handleAccordionToggle(categoryId)}
                                                                sx={{ mb: 2 }}
                                                            >
                                                                <AccordionSummary
                                                                    expandIcon={<span>▼</span>}
                                                                    sx={{
                                                                        '& .MuiAccordionSummary-content': {
                                                                            my: 1,
                                                                        },
                                                                    }}
                                                                >
                                                                    <Typography
                                                                        variant="h4"
                                                                        component="h2"
                                                                        sx={{
                                                                            fontWeight: 500,
                                                                        }}
                                                                    >
                                                                        {category}
                                                                    </Typography>
                                                                </AccordionSummary>
                                                                <AccordionDetails>

                                                            {Object.entries(
                                                                eventGroups,
                                                            ).map(
                                                                ([
                                                                    event,
                                                                    pageGroups,
                                                                ]) => {
                                                                    const eventId = `event-${category.replace(/\s+/g, '-')}-${event.replace(/\s+/g, '-')}`;
                                                                    return (
                                                                        <Box key={event} sx={{ mb: 2 }}>
                                                                            {/* H3 - Life Event (only if different from selection) */}
                                                                            {event !== selections.lifeEvent && (
                                                                                <Box sx={{ mb: 1 }}>
                                                                                    <Typography
                                                                                        variant="h5"
                                                                                        component="h3"
                                                                                        sx={{ fontWeight: 500, color: "#1976d2", mb: 1 }}
                                                                                    >
                                                                                        {event}
                                                                                    </Typography>
                                                                                    
                                                                                        {Object.entries(pageGroups).map(([pageTitle, items]) => (
                                                                                            <Box key={pageTitle} sx={{ mb: 3 }}>
                                                                                                {/* Render content fragments as they originally appeared */}
                                                                                                {items.map(
                                                                                        (
                                                                                            item,
                                                                                        ) => (
                                                                                            <Box
                                                                                                key={
                                                                                                    item.id
                                                                                                }
                                                                                                sx={{
                                                                                                    mb: 3,
                                                                                                }}
                                                                                            >
                                                                                                {item.content_html ? (
                                                                                                    <Box
                                                                                                        className="fragment-content"
                                                                                                        dangerouslySetInnerHTML={{
                                                                                                            __html: item.content_html,
                                                                                                        }}
                                                                                                    />
                                                                                                ) : (
                                                                                                    <Box className="fragment-content">
                                                                                                        <Typography
                                                                                                            variant="body1"
                                                                                                            paragraph
                                                                                                        >
                                                                                                            {
                                                                                                                item.description
                                                                                                            }
                                                                                                        </Typography>
                                                                                                    </Box>
                                                                                                )}

                                                                                                {/* Source attribution */}
                                                                                                <Typography
                                                                                                    variant="caption"
                                                                                                    sx={{
                                                                                                        display:
                                                                                                            "block",
                                                                                                        color: "text.secondary",
                                                                                                        fontStyle:
                                                                                                            "italic",
                                                                                                        mb: 2,
                                                                                                    }}
                                                                                                >
                                                                                                    Source:{" "}
                                                                                                    <Link
                                                                                                        href={
                                                                                                            item.url
                                                                                                        }
                                                                                                        target="_blank"
                                                                                                        sx={{
                                                                                                            color: "inherit",
                                                                                                            textDecoration: "underline",
                                                                                                        }}
                                                                                                    >
                                                                                                        {pageTitle} | {item.provider}
                                                                                                    </Link>
                                                                                                </Typography>
                                                                                            </Box>
                                                                                        ),
                                                                                    )}
                                                                                            </Box>
                                                                                        ))}
                                                                                </Box>
                                                                            )}
                                                                            
                                                                            {/* Handle case where event matches selection - render pages directly */}
                                                                            {event === selections.lifeEvent && (
                                                                                Object.entries(pageGroups).map(([pageTitle, items]) => (
                                                                                    <Box key={pageTitle} sx={{ mb: 3 }}>
                                                                                        {/* Render content fragments as they originally appeared */}
                                                                                        {items.map((item) => (
                                                                                            <Box
                                                                                                key={item.id}
                                                                                                sx={{
                                                                                                    mb: 3,
                                                                                                }}
                                                                                            >
                                                                                                {item.content_html ? (
                                                                                                    <Box
                                                                                                        className="fragment-content"
                                                                                                        dangerouslySetInnerHTML={{
                                                                                                            __html: item.content_html,
                                                                                                        }}
                                                                                                    />
                                                                                                ) : (
                                                                                                    <Box className="fragment-content">
                                                                                                        <Typography
                                                                                                            variant="body1"
                                                                                                            paragraph
                                                                                                        >
                                                                                                            {item.description}
                                                                                                        </Typography>
                                                                                                    </Box>
                                                                                                )}
                                                                                                
                                                                                                {/* Source attribution */}
                                                                                                <Typography
                                                                                                    variant="caption"
                                                                                                    sx={{
                                                                                                        display: "block",
                                                                                                        color: "text.secondary",
                                                                                                        fontStyle: "italic",
                                                                                                        mb: 2,
                                                                                                    }}
                                                                                                >
                                                                                                    Source:{" "}
                                                                                                    <Link
                                                                                                        href={item.url}
                                                                                                        target="_blank"
                                                                                                        sx={{
                                                                                                            color: "inherit",
                                                                                                            textDecoration: "underline",
                                                                                                        }}
                                                                                                    >
                                                                                                        {pageTitle} | {item.provider}
                                                                                                    </Link>
                                                                                                </Typography>
                                                                                            </Box>
                                                                                        ))}
                                                                                    </Box>
                                                                                ))
                                                                            )}
                                                                        </Box>
                                                                    );
                                                                }
                                                            )}
                                                                </AccordionDetails>
                                                            </Accordion>
                                                        );
                                                    }
                                                );
                                            })()}
                                        </Box>
                                    )}

                                    {/* Browse Mode - Checklist */}
                                    {mode === "browse" && (
                                        <>
                                            {/* Progress Bar (Browse mode only) */}
                                            <Box sx={{ mb: 3 }}>
                                                <Box
                                                    sx={{
                                                        display: "flex",
                                                        justifyContent:
                                                            "space-between",
                                                        mb: 1,
                                                    }}
                                                >
                                                    <Typography variant="h5">
                                                        Your Checklist
                                                    </Typography>
                                                    <Typography
                                                        variant="body2"
                                                        color="text.secondary"
                                                    >
                                                        {completedTasks.length}{" "}
                                                        of {results.length}{" "}
                                                        steps complete
                                                    </Typography>
                                                </Box>
                                                <LinearProgress
                                                    variant="determinate"
                                                    value={progress}
                                                />

                                                <Box
                                                    sx={{
                                                        mt: 2,
                                                        display: "flex",
                                                        gap: 1,
                                                    }}
                                                >
                                                    <Button
                                                        size="small"
                                                        startIcon={
                                                            <span className="material-icons">
                                                                push_pin
                                                            </span>
                                                        }
                                                    >
                                                        Pin to dashboard
                                                    </Button>
                                                    <Button
                                                        size="small"
                                                        startIcon={
                                                            <span className="material-icons">
                                                                share
                                                            </span>
                                                        }
                                                        onClick={(e) =>
                                                            setExportAnchor(
                                                                e.currentTarget,
                                                            )
                                                        }
                                                    >
                                                        Export
                                                    </Button>
                                                    <Menu
                                                        anchorEl={exportAnchor}
                                                        open={Boolean(
                                                            exportAnchor,
                                                        )}
                                                        onClose={() =>
                                                            setExportAnchor(
                                                                null,
                                                            )
                                                        }
                                                    >
                                                        <MenuItem
                                                            onClick={() =>
                                                                window.print()
                                                            }
                                                        >
                                                            <ListItemIcon>
                                                                <span className="material-icons">
                                                                    print
                                                                </span>
                                                            </ListItemIcon>
                                                            Print
                                                        </MenuItem>
                                                        <MenuItem>
                                                            <ListItemIcon>
                                                                <span className="material-icons">
                                                                    picture_as_pdf
                                                                </span>
                                                            </ListItemIcon>
                                                            Download PDF
                                                        </MenuItem>
                                                        <MenuItem>
                                                            <ListItemIcon>
                                                                <span className="material-icons">
                                                                    description
                                                                </span>
                                                            </ListItemIcon>
                                                            Download DOCX
                                                        </MenuItem>
                                                        <Divider />
                                                        <MenuItem>
                                                            <ListItemIcon>
                                                                <span className="material-icons">
                                                                    share
                                                                </span>
                                                            </ListItemIcon>
                                                            Share via email
                                                        </MenuItem>
                                                    </Menu>
                                                </Box>
                                            </Box>

                                            {/* Results organized by hierarchy */}
                                            <Box>
                                                {Object.entries(
                                                    results.reduce(
                                                        (acc, item) => {
                                                            const activity =
                                                                item.hierarchy;
                                                            if (!acc[activity])
                                                                acc[activity] =
                                                                    [];
                                                            acc[activity].push(
                                                                item,
                                                            );
                                                            return acc;
                                                        },
                                                        {},
                                                    ),
                                                ).map(
                                                    (
                                                        [activity, items],
                                                        index,
                                                    ) => {
                                                        const completedInGroup =
                                                            items.filter(
                                                                (item) =>
                                                                    completedTasks.includes(
                                                                        item.id,
                                                                    ),
                                                            ).length;

                                                        return (
                                                            <Accordion
                                                                key={activity}
                                                                defaultExpanded={
                                                                    index === 0
                                                                }
                                                            >
                                                                <AccordionSummary
                                                                    expandIcon={
                                                                        <span className="material-icons">
                                                                            expand_more
                                                                        </span>
                                                                    }
                                                                >
                                                                    <Box
                                                                        sx={{
                                                                            display:
                                                                                "flex",
                                                                            alignItems:
                                                                                "center",
                                                                            width: "100%",
                                                                            pr: 2,
                                                                        }}
                                                                    >
                                                                        <Typography
                                                                            sx={{
                                                                                flexGrow: 1,
                                                                            }}
                                                                        >
                                                                            {
                                                                                activity
                                                                            }{" "}
                                                                            (
                                                                            {
                                                                                items.length
                                                                            }
                                                                            )
                                                                        </Typography>
                                                                        <Chip
                                                                            size="small"
                                                                            label={
                                                                                completedInGroup ===
                                                                                items.length
                                                                                    ? "Complete"
                                                                                    : completedInGroup >
                                                                                        0
                                                                                      ? "In progress"
                                                                                      : "Not started"
                                                                            }
                                                                            color={
                                                                                completedInGroup ===
                                                                                items.length
                                                                                    ? "success"
                                                                                    : completedInGroup >
                                                                                        0
                                                                                      ? "info"
                                                                                      : "default"
                                                                            }
                                                                        />
                                                                    </Box>
                                                                </AccordionSummary>
                                                                <AccordionDetails>
                                                                    <List>
                                                                        {items.map(
                                                                            (
                                                                                item,
                                                                            ) => (
                                                                                <ListItem
                                                                                    key={
                                                                                        item.id
                                                                                    }
                                                                                    sx={{
                                                                                        opacity:
                                                                                            completedTasks.includes(
                                                                                                item.id,
                                                                                            )
                                                                                                ? 0.6
                                                                                                : 1,
                                                                                        "&:hover":
                                                                                            {
                                                                                                bgcolor:
                                                                                                    "action.hover",
                                                                                            },
                                                                                    }}
                                                                                >
                                                                                    <ListItemIcon>
                                                                                        <Checkbox
                                                                                            checked={completedTasks.includes(
                                                                                                item.id,
                                                                                            )}
                                                                                            onChange={() =>
                                                                                                toggleTask(
                                                                                                    item.id,
                                                                                                )
                                                                                            }
                                                                                        />
                                                                                    </ListItemIcon>
                                                                                    <ListItemText
                                                                                        primary={
                                                                                            <Box
                                                                                                sx={{
                                                                                                    display:
                                                                                                        "flex",
                                                                                                    alignItems:
                                                                                                        "center",
                                                                                                    gap: 1,
                                                                                                }}
                                                                                            >
                                                                                                {
                                                                                                    item.title
                                                                                                }
                                                                                                {item.state !==
                                                                                                    "National" && (
                                                                                                    <Chip
                                                                                                        size="small"
                                                                                                        label={
                                                                                                            item.state
                                                                                                        }
                                                                                                    />
                                                                                                )}
                                                                                            </Box>
                                                                                        }
                                                                                        secondary={
                                                                                            <>
                                                                                                <Typography
                                                                                                    variant="body2"
                                                                                                    component="span"
                                                                                                >
                                                                                                    {
                                                                                                        item.description
                                                                                                    }
                                                                                                </Typography>
                                                                                                <br />
                                                                                                <Typography
                                                                                                    variant="caption"
                                                                                                    color="text.secondary"
                                                                                                >
                                                                                                    Provider:{" "}
                                                                                                    {
                                                                                                        item.provider
                                                                                                    }
                                                                                                </Typography>
                                                                                            </>
                                                                                        }
                                                                                        sx={{
                                                                                            textDecoration:
                                                                                                completedTasks.includes(
                                                                                                    item.id,
                                                                                                )
                                                                                                    ? "line-through"
                                                                                                    : "none",
                                                                                        }}
                                                                                    />
                                                                                    <IconButton
                                                                                        href={
                                                                                            item.url
                                                                                        }
                                                                                        target="_blank"
                                                                                        size="small"
                                                                                    >
                                                                                        <span className="material-icons">
                                                                                            open_in_new
                                                                                        </span>
                                                                                    </IconButton>
                                                                                </ListItem>
                                                                            ),
                                                                        )}
                                                                    </List>
                                                                </AccordionDetails>
                                                            </Accordion>
                                                        );
                                                    },
                                                )}
                                            </Box>
                                        </>
                                    )}

                                    {/* Search Mode - Results Grid */}
                                    {mode === "search" && (
                                        <Box>
                                            <Typography
                                                variant="h5"
                                                gutterBottom
                                            >
                                                Search Results ({results.length}
                                                )
                                            </Typography>
                                            
                                            {/* AI Summary Section */}
                                            {(aiSummary || loadingSummary) && results.length > 0 && (
                                                <Paper 
                                                    sx={{ 
                                                        p: 2, 
                                                        mb: 3, 
                                                        backgroundColor: '#f5f5f5',
                                                        border: '1px solid #e0e0e0'
                                                    }}
                                                >
                                                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                                        <span className="material-icons" style={{ marginRight: 8, color: '#1976d2' }}>
                                                            summarize
                                                        </span>
                                                        <Typography variant="h6" component="h3">
                                                            AI Summary
                                                        </Typography>
                                                    </Box>
                                                    {loadingSummary ? (
                                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                                            <CircularProgress size={16} />
                                                            <Typography variant="body2" color="text.secondary">
                                                                Generating summary of search results...
                                                            </Typography>
                                                        </Box>
                                                    ) : (
                                                        <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
                                                            {aiSummary}
                                                        </Typography>
                                                    )}
                                                </Paper>
                                            )}
                                            
                                            <Grid container spacing={2}>
                                                {results.map((item) => (
                                                    <Grid
                                                        item
                                                        xs={12}
                                                        md={6}
                                                        key={item.id}
                                                    >
                                                        <Card variant="outlined">
                                                            <CardContent>
                                                                <Typography
                                                                    variant="h6"
                                                                    gutterBottom
                                                                >
                                                                    {item.title}
                                                                </Typography>
                                                                <Typography
                                                                    variant="body2"
                                                                    color="text.secondary"
                                                                    paragraph
                                                                >
                                                                    {
                                                                        item.description
                                                                    }
                                                                </Typography>
                                                                <Box
                                                                    sx={{
                                                                        display:
                                                                            "flex",
                                                                        gap: 1,
                                                                        flexWrap:
                                                                            "wrap",
                                                                        mb: 2,
                                                                    }}
                                                                >
                                                                    <Chip
                                                                        size="small"
                                                                        label={
                                                                            item.category
                                                                        }
                                                                        color="primary"
                                                                        variant="outlined"
                                                                    />
                                                                    <Chip
                                                                        size="small"
                                                                        label={
                                                                            item.provider
                                                                        }
                                                                    />
                                                                    {item.state !==
                                                                        "National" && (
                                                                        <Chip
                                                                            size="small"
                                                                            label={
                                                                                item.state
                                                                            }
                                                                            variant="outlined"
                                                                        />
                                                                    )}
                                                                </Box>
                                                                <Button
                                                                    size="small"
                                                                    href={
                                                                        item.url
                                                                    }
                                                                    target="_blank"
                                                                    endIcon={
                                                                        <span className="material-icons">
                                                                            open_in_new
                                                                        </span>
                                                                    }
                                                                >
                                                                    View details
                                                                </Button>
                                                            </CardContent>
                                                        </Card>
                                                    </Grid>
                                                ))}
                                            </Grid>
                                        </Box>
                                    )}
                                </>
                            )}

                            {/* Empty State */}
                            {!loading &&
                                results.length === 0 &&
                                mode === "search" &&
                                searchQuery && (
                                    <Paper sx={{ p: 4, textAlign: "center" }}>
                                        <Typography variant="h6" gutterBottom>
                                            No results found
                                        </Typography>
                                        <Typography
                                            variant="body2"
                                            color="text.secondary"
                                        >
                                            Try adjusting your search terms or
                                            filters
                                        </Typography>
                                    </Paper>
                                )}
                        </Container>

                        {/* Footer */}
                        <Box
                            component="footer"
                            sx={{
                                bgcolor: "#000",
                                color: "white",
                                py: 6,
                                mt: 8,
                            }}
                        >
                            <Container maxWidth="lg">
                                <Grid container spacing={4}>
                                    <Grid item xs={12} md={3}>
                                        <Typography variant="h6" gutterBottom>
                                            About this site
                                        </Typography>
                                        <List dense>
                                            <ListItem>
                                                <ListItemText primary="About myGov" />
                                            </ListItem>
                                            <ListItem>
                                                <ListItemText primary="Help using myGov" />
                                            </ListItem>
                                            <ListItem>
                                                <ListItemText primary="Contact us" />
                                            </ListItem>
                                        </List>
                                    </Grid>
                                    <Grid item xs={12} md={3}>
                                        <Typography variant="h6" gutterBottom>
                                            Browse
                                        </Typography>
                                        <List dense>
                                            <ListItem>
                                                <ListItemText primary="Raising kids" />
                                            </ListItem>
                                            <ListItem>
                                                <ListItemText primary="Living arrangements" />
                                            </ListItem>
                                            <ListItem>
                                                <ListItemText primary="Work" />
                                            </ListItem>
                                        </List>
                                    </Grid>
                                    <Grid item xs={12} md={6}>
                                        <Typography
                                            variant="body2"
                                            sx={{ mt: 2 }}
                                        >
                                            We acknowledge the Traditional
                                            Custodians of the lands we live on.
                                            We pay our respects to all
                                            Aboriginal and Torres Strait
                                            Islander peoples.
                                        </Typography>
                                    </Grid>
                                </Grid>
                            </Container>
                        </Box>
                    </>
                );
            }

            // Render the app
            ReactDOM.render(<App />, document.getElementById("root"));
        </script>
    </body>
</html>
